<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>reTerminal Dashboard Designer · YAML Snippet Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <!-- Google Fonts for text preview -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=Roboto:wght@400;500;700&family=Open+Sans:wght@400;500;700&family=Lato:wght@400;700&family=Montserrat:wght@400;500;700&family=Poppins:wght@400;500;700&display=swap" rel="stylesheet">
  
  <style>
    :root {
      --bg: #0f1115;
      --bg-elevated: #181b22;
      --accent: #52c7ea;
      --accent-soft: rgba(82, 199, 234, 0.16);
      --border-subtle: #2a2f3a;
      --text: #e5e9f0;
      --muted: #7b8190;
      --danger: #ff6b81;
      --font: system-ui, -apple-system, BlinkMacSystemFont, -sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: var(--font);
      background: radial-gradient(circle at top left, #1c1f26 0, #050609 40%, #020308 100%);
      color: var(--text);
      display: flex;
    }

    .sidebar {
      width: 260px;
      background: linear-gradient(to bottom, #151821, #0c0f15);
      border-right: 1px solid var(--border-subtle);
      padding: 16px 14px 12px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      overflow-y: auto;
      position: relative;
    }

    .sidebar h1 {
      font-size: 16px;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 8px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .logo-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 12px var(--accent);
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      font-size: 10px;
      color: var(--muted);
      margin-top: 6px;
    }

    .pill span {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 8px var(--accent);
    }

    .sidebar-section-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--muted);
      margin-bottom: 6px;
    }

    select,
    input,
    button,
    textarea {
      font-family: var(--font);
    }

    .select,
    .input {
      width: 100%;
      padding: 7px 9px;
      font-size: 12px;
      border-radius: 6px;
      border: 1px solid var(--border-subtle);
      background: #0f1118;
      color: var(--text);
      outline: none;
    }

    .select:focus,
    .input:focus,
    textarea:focus {
      border-color: var(--accent);
      box-shadow:  0 0 0 1px var(--accent-soft);
    }

    .sidebar-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .btn {
      border: 1px solid var(--accent);
      background: transparent;
      color: var(--accent);
      padding: 6px 9px;
      border-radius: 6px;
      font-size: 11px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: all 0.16s ease;
    }

    .btn:hover {
      background: var(--accent-soft);
      transform: translateY(-1px);
      box-shadow: 0 6px 14px rgba(0, 0, 0, 0.35);
    }

    .btn-secondary {
      border-color: var(--border-subtle);
      color: var(--muted);
    }

    .btn-secondary:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .btn-full {
      width: 100%;
      justify-content: center;
      margin-top: 4px;
    }

    .page-list,
    .widget-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .item {
      padding: 5px 7px;
      border-radius: 5px;
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      cursor: pointer;
      border: 1px solid transparent;
      color: var(--muted);
    }

    .item span.label {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .item small {
      font-size: 9px;
      opacity: 0.7;
    }

    .item.active {
      background: var(--accent-soft);
      border-color: var(--accent);
      color: var(--accent);
    }

    .item:hover {
      background: #151822;
      border-color: var(--border-subtle);
    }

    .item .tag {
      padding: 1px 5px;
      border-radius: 999px;
      font-size: 8px;
      border: 1px solid var(--border-subtle);
      color: var(--muted);
    }

    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 10px 14px 8px;
      gap: 8px;
      overflow: hidden;
      min-width: 0;
      min-height: 0;
    }

    .main-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }

    .main-header-title {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .main-header-title h2 {
      margin: 0;
      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .main-header-title span {
      font-size: 11px;
      color: var(--muted);
    }

    .main-header-actions {
      display: flex;
      gap: 6px;
      align-items: center;
      flex-wrap: wrap;
    }

    .main-header-pill {
      padding: 3px 7px;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      font-size: 9px;
      color: var(--muted);
    }

    .canvas-wrap {
      display: flex;
      flex-direction: row;
      gap: 8px;
      align-items: flex-start;
      justify-content: center;
      min-width: 0;
      overflow: hidden;
      flex: 1;
      min-height: 0;
    }

    .centered-stack {
      flex: 1 1 auto;
      min-width: 0;
      max-width: 100%;
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 100%;
      align-items: center;
    }

    .canvas-area {
      flex: 1 1 auto;
      min-height: 300px;
      max-height: 70vh;
      width: 100%;
      max-width: 820px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      background: radial-gradient(circle at top, #171b22, #05070b);
      border-radius: 12px;
      border: 1px solid var(--border-subtle);
      padding: 10px;
      overflow: hidden;
    }

    .canvas-toolbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 10px;
      color: var(--muted);
      flex-shrink: 0;
    }

    .canvas-toolbar span strong {
      color: var(--accent);
      font-weight: 500;
    }

    .canvas {
      width: 800px;
      height: 480px;
      margin-top: 4px;
      background: #f5f5f5;
      border-radius: 10px;
      border: 1px solid #d0d0d0;
      position: relative;
      box-shadow: inset 0 0 0 1px #ffffff, 0 18px 40px rgba(0, 0, 0, 0.45);
      overflow: hidden;
      transition: all 0.16s ease;
      flex-shrink: 0;
    }

    .canvas.dark {
      background: #000000;
      border-color: #222222;
      box-shadow: inset 0 0 0 1px #222222, 0 18px 40px rgba(0, 0, 0, 0.7);
    }

    .canvas.landscape {
      width: 800px;
      height: 480px;
    }

    .canvas.portrait {
      width: 480px;
      height: 800px;
    }

    .right-panel {
      width: 260px;
      background: #0d1016;
      border-radius: 12px;
      border: 1px solid var(--border-subtle);
      padding: 8px 9px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      box-sizing: border-box;
      overflow-y: auto;
      position: relative;
    }

    .canvas-grid {
      position: absolute;
      inset: 0;
      background-image:
        linear-gradient(to right, rgba(0, 0, 0, 0.03) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(0, 0, 0, 0.03) 1px, transparent 1px);
      background-size: 20px 20px;
      pointer-events: none;
    }

    .widget {
      position: absolute;
      font-size: 12px;
      color: #000000;
      cursor: move;
      display: block;
      user-select: none;
      -webkit-user-select: none;
      border: none;
      background: transparent;
      padding: 0;
    }

    .widget.active {
      outline: 1px solid var(--accent);
      box-shadow: 0 0 0 1px rgba(82, 199, 234, 0.4);
    }

    .widget-resize-handle {
      position: absolute;
      width: 11px;
      height: 11px;
      border-radius: 3px;
      background: var(--accent);
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.7);
      cursor: nwse-resize;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    .widget-resize-handle::after {
      content: "";
      width: 6px;
      height: 2px;
      border-radius: 2px;
      background: #0b0e13;
      transform: rotate(40deg);
      opacity: 0.9;
    }

    .snap-guide {
      position: absolute;
      background: rgba(82, 199, 234, 0.6);
      pointer-events: none;
      z-index: 50;
    }

    .snap-guide-vertical {
      width: 1px;
      top: 0;
      bottom: 0;
    }

    .snap-guide-horizontal {
      height: 1px;
      left: 0;
      right: 0;
    }

    .right-panel h3 {
      margin: 2px 0 2px 0;
      font-size: 10px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--muted);
    }

    .prop-label {
      font-size: 9px;
      text-transform: uppercase;
      color: var(--muted);
      letter-spacing: 0.12em;
      margin-top: 4px;
      margin-bottom: 2px;
    }

    .prop-input {
      width: 100%;
      padding: 5px 7px;
      font-size: 11px;
      border-radius: 5px;
      border: 1px solid var(--border-subtle);
      background: #05070b;
      color: var(--text);
      outline: none;
    }

    .prop-input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }

    .snippet-area {
      flex: 1 1 auto;
      min-height: 200px;
      width: 900px;
      max-width: 100%;
      margin: 0;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .snippet-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 4px;
    }

    .snippet-header span {
      font-size: 9px;
      color: var(--muted);
    }

    .snippet-actions {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .snippet-box {
      flex: 1 1 auto;
      border-radius: 6px;
      background: #05070b;
      border: 1px solid var(--border-subtle);
      padding: 8px;
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New";
      font-size: 9px;
      color: #d8dee9;
      white-space: pre;
      overflow-y: auto;
      overflow-x: auto;
      min-height: 0;
      resize: none;
    }

    .status-bar {
      font-size: 8px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 4px;
    }

    .status-bar span.emph {
      color: var(--accent);
    }

    .badge {
      padding: 1px 6px;
      border-radius: 999px;
      border: 1px solid var(--accent);
      color: var(--accent);
      font-size: 8px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    .hidden {
      display: none !important;
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(2, 4, 10, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .modal {
      background: #060910;
      border-radius: 10px;
      border: 1px solid var(--border-subtle);
      padding: 10px;
      width: 90%;
      max-width: 1100px;
      height: 90%;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      color: var(--muted);
    }

    .modal-body {
      flex: 1;
      overflow: auto;
    }

    .modal-body pre {
      white-space: pre;
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New";
      font-size: 10px;
      color: #d8dee9;
    }

    .modal-body textarea {
      width: 100%;
      height: 260px;
      background: #05070b;
      color: #d8dee9;
      border-radius: 6px;
      border: 1px solid var(--border-subtle);
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New";
      font-size: 10px;
      padding: 6px;
      resize: vertical;
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 6px;
      margin-top: 4px;
    }

    @font-face {
      font-family: "MDI";
      src:
        url("materialdesignicons-webfont.ttf") format("truetype"),
        url("/local/esphome/fonts/materialdesignicons-webfont.ttf") format("truetype"),
        url("/local/reterminal_dashboard/materialdesignicons-webfont.ttf") format("truetype"),
        url("/hacsfiles/reterminal_dashboard/materialdesignicons-webfont.ttf") format("truetype"),
        url("/reterminal-dashboard/materialdesignicons-webfont.ttf") format("truetype");
      font-weight: normal;
      font-style: normal;
    }

    .mdi-icon-preview {
      font-family: "MDI", system-ui, -apple-system, BlinkMacSystemFont, -sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Responsive vertical space management */
    @media (max-height: 900px) {
      .canvas-area {
        max-height: 65vh;
        min-height: 250px;
      }
      .snippet-area {
        max-height: 30vh;
        min-height: 150px;
      }
      .canvas.portrait {
        transform: scale(0.7);
        transform-origin: top center;
      }
    }

    @media (max-height: 700px) {
      .canvas-area {
        max-height: 60vh;
        min-height: 200px;
      }
      .snippet-area {
        max-height: 25vh;
        min-height: 120px;
      }
    }

    @media (max-width: 1600px) {
      .canvas-area {
        max-width: 750px;
      }
      .snippet-area {
        width: 750px;
        max-width: 750px;
      }
    }

    @media (max-width: 1400px) {
      .canvas {
        transform: scale(0.8);
        transform-origin: top center;
      }
      .canvas.portrait {
        transform: scale(0.6);
        transform-origin: top center;
      }
      .canvas-area {
        max-width: 650px;
      }
      .snippet-area {
        width: 650px;
        max-width: 650px;
      }
    }

    @media (max-width: 1200px) {
      .canvas-area {
        max-width: 550px;
      }
      .snippet-area {
        width: 550px;
        max-width: 550px;
      }
    }

    /* Portrait mode specific adjustments */
    @media (orientation: portrait) and (max-width: 768px) {
      body {
        flex-direction: column;
      }
      
      .sidebar {
        width: 100%;
        height: 120px;
        flex-direction: row;
        overflow-x: auto;
        overflow-y: hidden;
        border-right: none;
        border-bottom: 1px solid var(--border-subtle);
      }
      
      .canvas-wrap {
        flex-direction: column;
      }
      
      .right-panel {
        width: 100%;
        height: 150px;
        overflow-x: auto;
        overflow-y: hidden;
      }
      
      .canvas-area {
        min-height: 180px;
        max-height: 50vh;
      }
      
      .snippet-area {
        min-height: 100px;
        max-height: 30vh;
      }
    }
  </style>
</head>
<body>
  <aside class="sidebar">
    <div>
      <h1><span class="logo-dot"></span> reTerminal Designer</h1>
      <div class="pill">
        <span></span>
        <div>ESPHome YAML snippet · Local + HA backend</div>
      </div>
    </div>

    <div class="sidebar-group">
      <div class="sidebar-section-label">Target device</div>
      <div class="select" style="display:flex;align-items:center;justify-content:space-between;gap:6px;">
        <div>
          <div style="font-size:11px;color:var(--text);">reTerminal E1001</div>
          <div style="font-size:9px;color:var(--muted);">ESP32-S3 · 800x480 epaper</div>
        </div>
        <div class="badge">MVP</div>
      </div>
      <div class="status-bar">
        <span>Base ESPHome config is managed in ESPHome UI.</span>
      </div>
    </div>

    <div class="sidebar-group">
      <div class="sidebar-section-label">Pages</div>
      <div id="pageList" class="page-list"></div>
      <button id="addPageBtn" class="btn btn-secondary btn-full">+ Add page</button>
      <button id="clearAllBtn" class="btn btn-secondary btn-full" style="margin-top:4px;" title="Remove all widgets from current page">Clear current page</button>
    </div>

    <div class="sidebar-group">
      <div class="sidebar-section-label">Widgets</div>
      <div id="widgetPalette" class="widget-list">
        <div class="item" data-widget-type="label">
          <span class="label">Floating text</span>
          <span class="tag">Text</span>
        </div>
        <div class="item" data-widget-type="sensor_text">
          <span class="label">Sensor text</span>
          <span class="tag">Entity</span>
        </div>
        <div class="item" data-widget-type="datetime">
          <span class="label">Date & Time</span>
          <span class="tag">Time</span>
        </div>
        <div class="item" data-widget-type="progress_bar">
          <span class="label">Progress bar</span>
          <span class="tag">Entity</span>
        </div>
        <div class="item" data-widget-type="icon">
          <span class="label">MDI icon</span>
          <span class="tag">Icon</span>
        </div>
        <div class="item" data-widget-type="battery_icon">
          <span class="label">Battery icon</span>
          <span class="tag">Entity</span>
        </div>
        <div class="item" data-widget-type="shape_rect">
          <span class="label">Rectangle / box</span>
          <span class="tag">Shape</span>
        </div>
        <div class="item" data-widget-type="shape_circle">
          <span class="label">Circle</span>
          <span class="tag">Shape</span>
        </div>
        <div class="item" data-widget-type="line">
          <span class="label">Line</span>
          <span class="tag">Shape</span>
        </div>
        <div class="item" data-widget-type="image">
          <span class="label">Image</span>
          <span class="tag">Media</span>
        </div>
        <div class="item" data-widget-type="online_image">
          <span class="label">Puppet / Remote image</span>
          <span class="tag">Remote</span>
        </div>
      </div>
    </div>

    <div class="sidebar-group">
      <button id="saveLayoutBtn" class="btn btn-full">Save layout</button>
      <button id="generateSnippetBtn" class="btn btn-secondary btn-full">Generate ESPHome snippet</button>
      <div class="status-bar" id="sidebarStatus">
        <span>Layout status will appear here.</span>
        <span class="emph">Snippets are additive to your base ESPHome config.</span>
      </div>
    </div>
  </aside>

  <main class="main">
    <div class="main-header">
      <div class="main-header-title">
        <h2>Visual layout editor</h2>
        <span>Each widget on the canvas becomes part of your ESPHome display lambda.</span>
      </div>
      <div class="main-header-actions">
        <div class="main-header-pill">
          Canvas: <span id="canvasSizeLabel">800 x 480</span> px · reTerminal E-Ink
        </div>
        <select id="orientationSelect" class="select" style="width:auto;padding:3px 6px;font-size:9px;" title="Canvas orientation">
          <option value="landscape">Landscape 800x480</option>
          <option value="portrait">Portrait 480x800</option>
        </select>
      </div>
    </div>

    <div class="canvas-wrap">
      <div class="canvas-area-wrapper">
        <div class="centered-stack">
          <section class="canvas-area">
            <div class="canvas-toolbar">
              <span>Page: <strong id="currentPageName">Loading...</strong></span>
              <span>Place widgets to define what the reTerminal shows.</span>
            </div>
            <div id="canvas" class="canvas">
              <div class="canvas-grid"></div>
            </div>
          </section>

          <section class="snippet-area">
            <div class="snippet-header">
              <span>ESPHome YAML Configuration (editable - paste or modify, then click Update Layout)</span>
              <div class="snippet-actions">
                <button id="copySnippetBtn" class="btn btn-secondary" style="padding:3px 6px;font-size:9px;">Copy</button>
                <button id="fullscreenSnippetBtn" class="btn btn-secondary" style="padding:3px 6px;font-size:9px;">Fullscreen</button>
                <button id="updateLayoutBtn" class="btn btn-primary" style="padding:3px 8px;font-size:9px;font-weight:bold;">Update Layout from YAML</button>
              </div>
            </div>
            <textarea id="snippetBox" class="snippet-box"># Click "Generate ESPHome snippet" to see output here.
# This includes layout and minimal surrounding definitions.
# You can paste YAML here or edit it directly, then click "Update Layout from YAML" to import changes.
            </textarea>
            <div class="status-bar">
              <span>Edit YAML above and click "Update Layout from YAML" to import.</span>
              <span>Generated YAML can be pasted into ESPHome, then compiled and flashed.</span>
            </div>
          </section>
        </div>
      </div>

      <aside class="right-panel">
        <h3>Widget properties</h3>
        <div class="field" style="margin-bottom:2px;">
          <div class="prop-label">Editor options</div>
          <label style="display:flex;align-items:center;gap:6px;font-size:9px;color:var(--muted);">
            <input id="snapToggle" type="checkbox" checked style="width:auto;height:auto;margin:0;" />
            <span>Snap to guides</span>
          </label>
        </div>
        <div id="propertiesPanel">
          <div class="field">
            <span style="font-size:9px;color:var(--muted);">
              Select a widget on the canvas to edit its position, size, text, color, fill, shading, and line thickness.
            </span>
          </div>
        </div>
      </aside>
    </div>
  </main>

  <!-- Fullscreen snippet modal -->
  <div id="snippetFullscreenModal" class="modal-backdrop hidden">
    <div class="modal">
      <div class="modal-header">
        <div>ESPHome YAML snippet (fullscreen)</div>
        <button id="snippetFullscreenClose" class="btn btn-secondary">Close</button>
      </div>
      <div class="modal-body">
        <pre id="snippetFullscreenContent"></pre>
      </div>
    </div>
  </div>

  <!-- Import snippet modal -->
  <div id="importSnippetModal" class="modal-backdrop hidden">
    <div class="modal">
      <div class="modal-header">
        <div>Import ESPHome snippet</div>
        <button id="importSnippetCancel" class="btn btn-secondary">Cancel</button>
      </div>
      <div class="modal-body">
        <textarea id="importSnippetTextarea" placeholder="# Paste your ESPHome snippet here"></textarea>
        <div id="importSnippetError" class="prop-label" style="color: var(--danger);"></div>
      </div>
      <div class="modal-actions">
        <button id="importSnippetConfirm" class="btn">Import</button>
      </div>
    </div>
  </div>

  <!-- Page settings modal -->
  <div id="pageSettingsModal" class="modal-backdrop hidden">
    <div class="modal" style="max-width: 500px; height: auto;">
      <div class="modal-header">
        <div>Page Settings</div>
        <button id="pageSettingsClose" class="btn btn-secondary">Close</button>
      </div>
      <div class="modal-body">
        <div class="field">
          <div class="prop-label">Page Name</div>
          <input id="pageSettingsName" class="prop-input" type="text" placeholder="Page name" />
        </div>
        <div class="field">
          <div class="prop-label">Refresh Interval (seconds)</div>
          <input id="pageSettingsRefresh" class="prop-input" type="number" min="0" step="1" placeholder="Auto (uses ESPHome default)" />
          <div style="font-size: 9px; color: var(--muted); margin-top: 2px;">
            Leave empty for default. Set to 0 for manual refresh only. Recommended: 60-300 seconds.
          </div>
        </div>
      </div>
      <div class="modal-actions">
        <button id="pageSettingsSave" class="btn">Save</button>
      </div>
    </div>
  </div>

  <script>
    // --- Environment detection: HA backend vs standalone/offline ---
    function detectHaBackendBaseUrl() {
      try {
        const loc = window.location;
        if (loc.protocol === "file:") {
          return null;
        }
        if (
          loc.hostname === "homeassistant" ||
          loc.hostname === "hassio" ||
          loc.pathname.includes("/api/") ||
          loc.pathname.includes("/local/") ||
          loc.pathname.includes("/hacsfiles/") ||
          loc.pathname.includes("/reterminal-dashboard")
        ) {
          return `${loc.origin}/api/reterminal_dashboard`;
        }
        return null;
      } catch (e) {
        return null;
      }
    }

    const HA_API_BASE = detectHaBackendBaseUrl();

    function hasHaBackend() {
      return !!HA_API_BASE;
    }

    // --- HA Entity States Cache for Live Preview ---
    let entityStatesCache = {};
    let entityStatesFetchInProgress = false;

    async function fetchEntityStates() {
      if (!hasHaBackend()) {
        console.log("[EntityStates] No HA backend detected");
        return;
      }
      if (entityStatesFetchInProgress) return;

      entityStatesFetchInProgress = true;
      try {
        console.log("[EntityStates] Fetching from:", `${HA_API_BASE}/entities`);
        const resp = await fetch(`${HA_API_BASE}/entities?domains=sensor,binary_sensor,weather`);
        if (!resp.ok) {
          console.warn("[EntityStates] Failed to fetch:", resp.status);
          return;
        }
        const entities = await resp.json();
        if (!Array.isArray(entities)) {
          console.warn("[EntityStates] Invalid response format");
          return;
        }

        console.log(`[EntityStates] Received ${entities.length} entities`);

        const newCache = {};
        for (const entity of entities) {
          if (entity.entity_id && entity.state !== undefined) {
            const stateValue = entity.unit ? `${entity.state} ${entity.unit}` : entity.state;
            newCache[entity.entity_id] = stateValue;
          }
        }
        entityStatesCache = newCache;
        console.log(`[EntityStates] Cached ${Object.keys(newCache).length} entity states`);

        if (typeof renderCanvas === 'function') {
          renderCanvas();
        }
      } catch (err) {
        console.warn("[EntityStates] Error fetching:", err);
      } finally {
        entityStatesFetchInProgress = false;
      }
    }

    function getEntityState(entityId) {
      return entityStatesCache[entityId] || null;
    }

    if (hasHaBackend()) {
      fetchEntityStates();
      setInterval(fetchEntityStates, 30000);
    }

    function setImportError(message) {
      const importSnippetError = document.getElementById("importSnippetError");
      if (importSnippetError) {
        importSnippetError.textContent = message || "";
      }
    }

    function parseSnippetYamlOffline(yamlText) {
      const lines = yamlText.split(/\r?\n/);
      const lambdaLines = [];
      let inLambda = false;
      let lambdaIndent = 0;

      for (const rawLine of lines) {
        const line = rawLine.replace(/\t/g, "    ");

        if (!inLambda && line.match(/^\s*lambda:\s*\|\-/)) {
          inLambda = true;
          continue;
        }

        if (inLambda) {
          if (!line.trim()) {
            lambdaLines.push("");
            continue;
          }

          const indentMatch = line.match(/^(\s+)/);
          if (!indentMatch) {
            inLambda = false;
            continue;
          }

          const indentLen = indentMatch[1].length;
          if (lambdaIndent === 0) {
            lambdaIndent = indentLen;
          }

          if (indentLen < lambdaIndent) {
            inLambda = false;
            continue;
          }

          const stripped = line.slice(lambdaIndent);
          lambdaLines.push(stripped);
        }
      }

      while (lines.length && lines[0].match(/^\s*#\s*Local preview snippet/)) {
        lines.shift();
      }
      while (lines.length && lines[lines.length - 1].match(/^\s*#\s*Backend unreachable/)) {
        lines.pop();
      }

      const pageMap = new Map();
      let currentPageIndex = null;

      for (const line of lambdaLines) {
        const pageMatch = line.match(/if\s*\(\s*id\s*\(\s*display_page\s*\)\s*==\s*(\d+)\s*\)/);
        if (pageMatch) {
          currentPageIndex = parseInt(pageMatch[1], 10);
          if (!pageMap.has(currentPageIndex)) {
            pageMap.set(currentPageIndex, []);
          }
        }
      }

      if (pageMap.size === 0) {
        pageMap.set(0, []);
      }

      const layout = {
        settings: {
          orientation: "landscape",
          dark_mode: false
        },
        pages: Array.from(pageMap.entries()).sort((a, b) => a[0] - b[0]).map(([idx, _]) => ({
          id: `page_${idx}`,
          name: `Page ${idx + 1}`,
          widgets: []
        }))
      };

      currentPageIndex = 0;

      function getCurrentPageWidgets() {
        const page = layout.pages.find((p, idx) => idx === currentPageIndex);
        return page ? page.widgets : layout.pages[0].widgets;
      }

      function parseWidgetMarker(comment) {
        const match = comment.match(/^\/\/\s*widget:(\w+)\s+(.+)$/);
        if (!match) return null;

        const widgetType = match[1];
        const propsStr = match[2];
        const props = {};

        const regex = /(\w+):((?:"[^"]*")|(?:[^\s]+))/g;
        let m;
        while ((m = regex.exec(propsStr)) !== null) {
          let value = m[2];
          if (value.startsWith('"') && value.endsWith('"')) {
            value = value.slice(1, -1);
          }
          props[m[1]] = value;
        }

        return { widgetType, props };
      }

      let skipRendering = false;

      for (const cmd of lambdaLines) {
        const trimmed = cmd.trim();
        if (!trimmed || trimmed.startsWith("#")) continue;

        const pageMatch = trimmed.match(/if\s*\(\s*id\s*\(\s*display_page\s*\)\s*==\s*(\d+)\s*\)/);
        if (pageMatch) {
          currentPageIndex = parseInt(pageMatch[1], 10);
          continue;
        }

        const widgets = getCurrentPageWidgets();

        if (skipRendering) {
          if (trimmed === "}" || trimmed === "}}" || trimmed.startsWith("//") || !trimmed.match(/^it\./)) {
            skipRendering = false;
          }
          if (trimmed.match(/^it\./)) {
            continue;
          }
        }

        if (trimmed.startsWith("//")) {
          const marker = parseWidgetMarker(trimmed);
          if (marker && marker.props.id && marker.props.type) {
            const p = marker.props;
            const widget = {
              id: p.id,
              type: p.type,
              x: parseInt(p.x || 0, 10),
              y: parseInt(p.y || 0, 10),
              width: parseInt(p.w || 100, 10),
              height: parseInt(p.h || 30, 10),
              title: p.title || "",
              entity_id: p.entity || p.ent || "",
              props: {}
            };

            if (p.type === "icon") {
              widget.props = {
                code: p.code || "F0595",
                size: parseInt(p.size || 48, 10),
                color: p.color || "black",
                fit_icon_to_frame: (p.fit === "true" || p.fit === "1")
              };
            } else if (p.type === "text" || p.type === "label") {
              widget.props = {
                text: p.text || "",
                font_size: parseInt(p.font_size || 12, 10),
                color: p.color || "black",
                font_style: p.font_style || "regular"
              };
            } else if (p.type === "sensor_text") {
              widget.props = {
                label_font_size: parseInt(p.label_font || 14, 10),
                value_font_size: parseInt(p.value_font || 20, 10),
                value_format: p.format || "label_value",
                color: p.color || "black",
                font_style: p.font_style || "regular",
                unit: p.unit || ""
              };
            } else if (p.type === "datetime") {
              widget.props = {
                format: p.format || "time_date",
                time_font_size: parseInt(p.time_font || 28, 10),
                date_font_size: parseInt(p.date_font || 16, 10),
                color: p.color || "black",
                font_style: p.font_style || "regular"
              };
            } else if (p.type === "progress_bar") {
              widget.props = {
                show_label: true,
                show_percentage: true,
                bar_height: parseInt(p.bar_height || 15, 10),
                border_width: parseInt(p.border || 1, 10),
                color: p.color || "black"
              };
            } else if (p.type === "battery_icon") {
              widget.props = {
                size: parseInt(p.size || 32, 10),
                color: p.color || "black"
              };
            } else if (p.type === "image") {
              widget.props = {
                path: p.path || "",
                invert: (p.invert === "true" || p.invert === "1")
              };
            } else if (p.type === "online_image") {
              widget.props = {
                url: p.url || "",
                invert: (p.invert === "true" || p.invert === "1")
              };
            } else if (p.type === "shape_rect") {
              widget.props = {
                fill: (p.fill === "true" || p.fill === "1"),
                border_width: parseInt(p.border || 1, 10),
                color: p.color || "black",
                opacity: parseInt(p.opacity || 100, 10)
              };
            } else if (p.type === "shape_circle") {
              widget.props = {
                fill: (p.fill === "true" || p.fill === "1"),
                border_width: parseInt(p.border || 1, 10),
                color: p.color || "black",
                opacity: parseInt(p.opacity || 100, 10)
              };
            } else if (p.type === "line") {
              widget.props = {
                stroke_width: parseInt(p.stroke || 1, 10),
                color: p.color || "black"
              };
            }

            widgets.push(widget);
            skipRendering = true;
            continue;
          }
          continue;
        }

        let m;

        m = trimmed.match(/^it\.rectangle\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*COLOR_OFF)?\s*\)\s*;?/);
        if (m) {
          widgets.push({
            id: "w_rect_" + widgets.length,
            type: "shape_rect",
            x: parseInt(m[1], 10),
            y: parseInt(m[2], 10),
            width: parseInt(m[3], 10),
            height: parseInt(m[4], 10),
            title: "",
            entity_id: "",
            props: {
              fill: false,
              border_width: 1,
              color: "black",
              opacity: 100
            }
          });
          continue;
        }

        m = trimmed.match(/^it\.filled_rectangle\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*COLOR_OFF)?\s*\)\s*;?/);
        if (m) {
          widgets.push({
            id: "w_frect_" + widgets.length,
            type: "shape_rect",
            x: parseInt(m[1], 10),
            y: parseInt(m[2], 10),
            width: parseInt(m[3], 10),
            height: parseInt(m[4], 10),
            title: "",
            entity_id: "",
            props: {
              fill: true,
              border_width: 1,
              color: "black",
              opacity: 100
            }
          });
          continue;
        }

        m = trimmed.match(/^it\.circle\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*COLOR_OFF)?\s*\)\s*;?/);
        if (m) {
          const r = parseInt(m[3], 10);
          widgets.push({
            id: "w_circle_" + widgets.length,
            type: "shape_circle",
            x: parseInt(m[1], 10) - r,
            y: parseInt(m[2], 10) - r,
            width: r * 2,
            height: r * 2,
            title: "",
            entity_id: "",
            props: {
              fill: false,
              border_width: 1,
              color: "black",
              opacity: 100
            }
          });
          continue;
        }

        m = trimmed.match(/^it\.filled_circle\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*COLOR_OFF)?\s*\)\s*;?/);
        if (m) {
          const r = parseInt(m[3], 10);
          widgets.push({
            id: "w_fcircle_" + widgets.length,
            type: "shape_circle",
            x: parseInt(m[1], 10) - r,
            y: parseInt(m[2], 10) - r,
            width: r * 2,
            height: r * 2,
            title: "",
            entity_id: "",
            props: {
              fill: true,
              border_width: 1,
              color: "black",
              opacity: 100
            }
          });
          continue;
        }

        m = trimmed.match(/^it\.line\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*;?/);
        if (m) {
          const x1 = parseInt(m[1], 10);
          const y1 = parseInt(m[2], 10);
          const x2 = parseInt(m[3], 10);
          const y2 = parseInt(m[4], 10);
          widgets.push({
            id: "w_line_" + widgets.length,
            type: "line",
            x: x1,
            y: y1,
            width: x2 - x1,
            height: y2 - y1,
            title: "",
            entity_id: "",
            props: {
              stroke_width: 1,
              color: "black"
            }
          });
          continue;
        }
      }

      return layout;
    }

    function applyImportedLayout(layout) {
      console.log("=== applyImportedLayout called ===");
      console.log("Layout:", JSON.stringify(layout, null, 2));
      
      if (!layout || !Array.isArray(layout.pages)) {
        console.error("Invalid layout - missing pages array");
        throw new Error("invalid_layout");
      }
      
      console.log("Pages before mapping:", layout.pages.length);
      layout.pages.forEach((p, i) => {
        console.log(`Page ${i}: ${p.widgets ? p.widgets.length : 0} widgets`);
      });
      
      pages = layout.pages.map((p, idx) => ({
        id: p.id || `page_${idx}`,
        name: p.name || `Page ${idx + 1}`,
        widgets: Array.isArray(p.widgets) ? p.widgets : []
      }));
      
      console.log("Pages after mapping:", pages.length);
      pages.forEach((p, i) => {
        console.log(`Mapped page ${i}: ${p.widgets.length} widgets`, p.widgets.map(w => w.id));
      });
      
      if (!pages.length) {
        console.warn("No pages, creating default empty page");
        pages = [
          {
            id: "page_0",
            name: "Imported",
            widgets: []
          }
        ];
      }
      settings = layout.settings || settings || {};
      currentPageIndex = 0;
      rebuildWidgetsIndex();
      applyOrientation(settings.orientation || "landscape");
      renderPagesSidebar();
      renderCanvas();
      renderPropertiesPanel();
      console.log("=== applyImportedLayout completed ===");
    }

    async function handleImportSnippetConfirm() {
      setImportError("");
      const textarea = document.getElementById("importSnippetTextarea");
      if (!textarea) return;
      const yaml = textarea.value || "";
      if (!yaml.trim()) {
        setImportError("Please paste an ESPHome YAML snippet first.");
        return;
      }

      if (hasHaBackend()) {
        try {
          const resp = await fetch(`${HA_API_BASE}/import_snippet`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({ yaml })
          });

          if (!resp.ok) {
            const data = await resp.json().catch(() => ({}));
            const msg =
              data.message ||
              data.error ||
              `Home Assistant import_snippet failed with status ${resp.status}`;
            setImportError(msg);
            return;
          }

          const result = await resp.json();
          applyImportedLayout(result);
          closeImportSnippetModal();
          sidebarStatus.innerHTML =
            '<span>Imported layout from snippet via Home Assistant backend.</span>';
          return;
        } catch (err) {
          console.warn("HA import_snippet request failed; falling back to offline parser.", err);
        }
      }

      try {
        const offlineLayout = parseSnippetYamlOffline(yaml);
        applyImportedLayout(offlineLayout);
        closeImportSnippetModal();
        sidebarStatus.innerHTML =
          '<span>Imported layout from snippet (offline client-side parser).</span>';
      } catch (err) {
        console.error("Offline snippet import failed", err);
        setImportError(
          "Could not parse snippet offline. Try importing within Home Assistant for full support."
        );
      }
    }

    function openImportSnippetModal() {
      const modal = document.getElementById("importSnippetModal");
      const textarea = document.getElementById("importSnippetTextarea");
      setImportError("");
      if (textarea) {
        textarea.value = "";
      }
      if (modal) {
        modal.classList.remove("hidden");
      }
    }

    function closeImportSnippetModal() {
      const modal = document.getElementById("importSnippetModal");
      if (modal) {
        modal.classList.add("hidden");
      }
    }

    const canvas = document.getElementById("canvas");
    const pageListEl = document.getElementById("pageList");
    const currentPageNameEl = document.getElementById("currentPageName");
    const propertiesPanel = document.getElementById("propertiesPanel");
    const sidebarStatus = document.getElementById("sidebarStatus");
    const snippetBox = document.getElementById("snippetBox");

    const addPageBtn = document.getElementById("addPageBtn");
    const saveLayoutBtn = document.getElementById("saveLayoutBtn");
    const generateSnippetBtn = document.getElementById("generateSnippetBtn");
    const copySnippetBtn = document.getElementById("copySnippetBtn");
    const fullscreenSnippetBtn = document.getElementById("fullscreenSnippetBtn");
    const updateLayoutBtn = document.getElementById("updateLayoutBtn");

    const snippetFullscreenModal = document.getElementById("snippetFullscreenModal");
    const snippetFullscreenContent = document.getElementById("snippetFullscreenContent");
    const snippetFullscreenClose = document.getElementById("snippetFullscreenClose");

    const importSnippetModal = document.getElementById("importSnippetModal");
    const importSnippetTextarea = document.getElementById("importSnippetTextarea");
    const importSnippetError = document.getElementById("importSnippetError");
    const importSnippetCancel = document.getElementById("importSnippetCancel");
    const importSnippetConfirm = document.getElementById("importSnippetConfirm");

    if (updateLayoutBtn) {
      updateLayoutBtn.addEventListener("click", async () => {
        const yaml = snippetBox.value || "";
        console.log("=== Update Layout from YAML clicked ===");
        console.log("YAML length:", yaml.length);
        console.log("YAML first 200 chars:", yaml.substring(0, 200));
        
        if (!yaml.trim()) {
          sidebarStatus.innerHTML = '<span style="color: var(--danger);">YAML is empty. Generate snippet first or paste YAML.</span>';
          return;
        }

        if (hasHaBackend()) {
          try {
            console.log("Trying HA backend import...");
            const resp = await fetch(`${HA_API_BASE}/import_snippet`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ yaml })
            });

            if (!resp.ok) {
              const data = await resp.json().catch(() => ({}));
              const msg = data.message || data.error || `Import failed with status ${resp.status}`;
              console.error("HA backend import failed:", msg);
              sidebarStatus.innerHTML = `<span style="color: var(--danger);">Import error: ${msg}</span>`;
              return;
            }

            const result = await resp.json();
            console.log("HA backend returned layout:", JSON.stringify(result, null, 2));
            applyImportedLayout(result);
            sidebarStatus.innerHTML = '<span style="color: var(--success);">✓ Layout updated from YAML via HA backend</span>';
            return;
          } catch (err) {
            console.warn("HA import_snippet failed, falling back to offline parser", err);
          }
        }

        try {
          console.log("Using offline parser...");
          const offlineLayout = parseSnippetYamlOffline(yaml);
          console.log("Offline parser returned layout:", JSON.stringify(offlineLayout, null, 2));
          applyImportedLayout(offlineLayout);
          sidebarStatus.innerHTML = '<span style="color: var(--success);">✓ Layout updated from YAML (offline parser)</span>';
        } catch (err) {
          console.error("Offline snippet import failed", err);
          sidebarStatus.innerHTML = '<span style="color: var(--danger);">Parse error: ' + err.message + '</span>';
        }
      });
    }

    if (importSnippetCancel) {
      importSnippetCancel.addEventListener("click", () => {
        closeImportSnippetModal();
      });
    }

    if (importSnippetConfirm) {
      importSnippetConfirm.addEventListener("click", () => {
        handleImportSnippetConfirm();
      });
    }

    let CANVAS_WIDTH = 800;
    let CANVAS_HEIGHT = 480;

    const SNAP_ENABLED_DEFAULT = true;
    const SNAP_DISTANCE = 10;
    let snapEnabled = SNAP_ENABLED_DEFAULT;

    let pages = [];
    let settings = {
      orientation: "landscape",
      dark_mode: false
    };
    let currentPageIndex = 0;
    let widgetsById = new Map();
    let selectedWidgetId = null;

    function initDefaultLayout() {
      pages = [
        {
          id: "page_0",
          name: "Overview",
          widgets: []
        }
      ];
      currentPageIndex = 0;
      rebuildWidgetsIndex();
      applyOrientation(settings.orientation || "landscape");
      renderPagesSidebar();
      renderCanvas();
      renderPropertiesPanel();
    }

    initDefaultLayout();

    function applyOrientation(orientation) {
      settings.orientation = orientation === "portrait" ? "portrait" : "landscape";
      const canvasEl = canvas;
      const sizeLabel = document.getElementById("canvasSizeLabel");
      const orientationSelect = document.getElementById("orientationSelect");
      if (orientationSelect) {
        orientationSelect.value = settings.orientation;
      }
      if (settings.orientation === "portrait") {
        CANVAS_WIDTH = 480;
        CANVAS_HEIGHT = 800;
        canvasEl.classList.remove("landscape");
        canvasEl.classList.add("portrait");
        sizeLabel.textContent = "480 x 800";
      } else {
        CANVAS_WIDTH = 800;
        CANVAS_HEIGHT = 480;
        canvasEl.classList.remove("portrait");
        canvasEl.classList.add("landscape");
        sizeLabel.textContent = "800 x 480";
      }
      canvasEl.style.width = CANVAS_WIDTH + "px";
      canvasEl.style.height = CANVAS_HEIGHT + "px";
      renderCanvas();
    }

    function rebuildWidgetsIndex() {
      widgetsById = new Map();
      for (const page of pages) {
        for (const w of page.widgets) {
          widgetsById.set(w.id, w);
        }
      }
    }

    function getCurrentPage() {
      return pages[currentPageIndex] || pages[0];
    }

    function renderPagesSidebar() {
      pageListEl.innerHTML = "";
      pages.forEach((page, index) => {
        const item = document.createElement("div");
        item.className = "item" + (index === currentPageIndex ? " active" : "");
        
        item.onclick = () => {
          currentPageIndex = index;
          selectedWidgetId = null;
          renderPagesSidebar();
          renderCanvas();
          renderPropertiesPanel();
          scheduleSnippetUpdate();
        };
        
        const label = document.createElement("span");
        label.className = "label";
        label.textContent = page.name;
        const tag = document.createElement("span");
        tag.className = "tag";
        tag.textContent = page.id;
        item.appendChild(label);
        item.appendChild(tag);
        
        const actionsContainer = document.createElement("div");
        actionsContainer.style.display = "flex";
        actionsContainer.style.gap = "2px";
        actionsContainer.style.marginLeft = "auto";
        
        const editBtn = document.createElement("button");
        editBtn.textContent = "⚙";
        editBtn.className = "btn btn-secondary";
        editBtn.style.padding = "1px 4px";
        editBtn.style.fontSize = "8px";
        editBtn.title = "Page settings";
        editBtn.onclick = (e) => {
          e.stopPropagation();
          openPageSettingsModal(page);
        };
        actionsContainer.appendChild(editBtn);
        
        if (pages.length > 1) {
          const deleteBtn = document.createElement("button");
          deleteBtn.textContent = "🗑";
          deleteBtn.className = "btn btn-secondary";
          deleteBtn.style.padding = "1px 4px";
          deleteBtn.style.fontSize = "8px";
          deleteBtn.style.color = "var(--danger)";
          deleteBtn.title = "Delete page";
          deleteBtn.onclick = (e) => {
            e.stopPropagation();
            if (confirm(`Delete page "${page.name}"? This cannot be undone.`)) {
              deletePage(index);
            }
          };
          actionsContainer.appendChild(deleteBtn);
        }
        
        item.appendChild(actionsContainer);
        
        pageListEl.appendChild(item);
      });
      const page = getCurrentPage();
      currentPageNameEl.textContent = page ? page.name : "None";
    }

    function createWidget(type) {
      const page = getCurrentPage();
      if (!page) return;
      const id = "w_" + Date.now() + "_" + Math.floor(Math.random() * 9999);
      const widget = {
        id,
        type,
        x: 40,
        y: 40,
        width: 120,
        height: 40,
        title: "",
        entity_id: "",
        props: {}
      };

      if (type === "label" || type === "text") {
        widget.type = "text";
        widget.props.text = "Text";
        widget.props.font_size = 20;
        widget.props.color = "black";
      } else if (type === "sensor_text") {
        widget.type = "sensor_text";
        widget.props.label_font_size = 14;
        widget.props.value_font_size = 20;
        widget.props.value_format = "label_value";
        widget.props.color = "black";
        widget.entity_id = "";
        widget.title = "";
      } else if (type === "datetime") {
        widget.type = "datetime";
        widget.width = 200;
        widget.height = 60;
        widget.props.format = "time_date";
        widget.props.time_font_size = 28;
        widget.props.date_font_size = 16;
        widget.props.color = "black";
      } else if (type === "progress_bar") {
        widget.type = "progress_bar";
        widget.width = 200;
        widget.height = 40;
        widget.entity_id = "";
        widget.title = "";
        widget.props.show_label = true;
        widget.props.show_percentage = true;
        widget.props.bar_height = 15;
        widget.props.border_width = 1;
        widget.props.color = "black";
      } else if (type === "battery_icon") {
        widget.type = "battery_icon";
        widget.width = 60;
        widget.height = 60;
        widget.entity_id = "";
        widget.props.size = 48;
        widget.props.color = "black";
      } else if (type === "shape_rect") {
        widget.type = "shape_rect";
        widget.props.fill = false;
        widget.props.border_width = 1;
        widget.props.color = "black";
        widget.props.opacity = 100;
      } else if (type === "shape_circle") {
        widget.type = "shape_circle";
        widget.width = 40;
        widget.height = 40;
        widget.props.fill = false;
        widget.props.border_width = 1;
        widget.props.color = "black";
        widget.props.opacity = 100;
      } else if (type === "icon") {
        widget.type = "icon";
        widget.width = 60;
        widget.height = 60;
        widget.props.code = "F0595";
        widget.props.size = 40;
        widget.props.color = "black";
        widget.props.font_ref = "font_mdi_medium";
        widget.props.fit_icon_to_frame = true;
      } else if (type === "line") {
        widget.type = "line";
        widget.width = 80;
        widget.height = 0;
        widget.props.stroke_width = 1;
        widget.props.color = "black";
      } else if (type === "image") {
        widget.type = "image";
        widget.width = 200;
        widget.height = 150;
        widget.props.path = "";
        widget.props.invert = false;
      } else if (type === "online_image") {
        widget.type = "online_image";
        widget.width = 800;
        widget.height = 480;
        widget.props.url = "";
        widget.props.interval_s = 300;
      }

      page.widgets.push(widget);
      widgetsById.set(widget.id, widget);
      selectedWidgetId = widget.id;
      renderCanvas();
      renderPropertiesPanel();
      scheduleSnippetUpdate();
    }

    function onWidgetPaletteClick(e) {
      const item = e.target.closest(".item[data-widget-type]");
      if (!item) return;
      const type = item.getAttribute("data-widget-type");
      createWidget(type);
    }

    function clearSnapGuides() {
      const guides = canvas.querySelectorAll(".snap-guide");
      guides.forEach((g) => g.remove());
    }

    function addSnapGuideVertical(x) {
      const guide = document.createElement("div");
      guide.className = "snap-guide snap-guide-vertical";
      guide.style.left = `${x}px`;
      canvas.appendChild(guide);
    }

    function addSnapGuideHorizontal(y) {
      const guide = document.createElement("div");
      guide.className = "snap-guide snap-guide-horizontal";
      guide.style.top = `${y}px`;
      canvas.appendChild(guide);
    }

    function getSnapLines(excludeWidgetId) {
      const page = getCurrentPage();
      const vertical = [];
      const horizontal = [];

      vertical.push(0, CANVAS_WIDTH / 2, CANVAS_WIDTH);
      horizontal.push(0, CANVAS_HEIGHT / 2, CANVAS_HEIGHT);

      if (page && Array.isArray(page.widgets)) {
        for (const w of page.widgets) {
          if (!w || w.id === excludeWidgetId) continue;
          const left = w.x;
          const right = w.x + (w.width || 0);
          const top = w.y;
          const bottom = w.y + (w.height || 0);
          const cx = left + (w.width || 0) / 2;
          const cy = top + (w.height || 0) / 2;
          vertical.push(left, cx, right);
          horizontal.push(top, cy, bottom);
        }
      }

      return {
        vertical,
        horizontal
      };
    }

    function applySnapToPosition(widget, x, y, ev) {
      if (!snapEnabled || (ev && ev.altKey)) {
        clearSnapGuides();
        return { x: Math.round(x), y: Math.round(y) };
      }

      const page = getCurrentPage();
      if (!page) {
        clearSnapGuides();
        return { x: Math.round(x), y: Math.round(y) };
      }

      const snapLines = getSnapLines(widget.id);
      const w = widget.width || 0;
      const h = widget.height || 0;

      const left = x;
      const right = x + w;
      const cx = x + w / 2;
      const top = y;
      const bottom = y + h;
      const cy = y + h / 2;

      let snappedX = x;
      let snappedY = y;
      let snappedV = null;
      let snappedH = null;

      const vCandidates = [
        { val: left, offset: (val, line) => line, apply: (line) => (snappedX = line) },
        { val: cx, offset: (val, line) => line - w / 2, apply: (line) => (snappedX = line - w / 2) },
        { val: right, offset: (val, line) => line - w, apply: (line) => (snappedX = line - w) }
      ];

      let bestDeltaV = SNAP_DISTANCE + 1;
      for (const cand of vCandidates) {
        for (const line of snapLines.vertical) {
          const delta = Math.abs(cand.val - line);
          if (delta <= SNAP_DISTANCE && delta < bestDeltaV) {
            bestDeltaV = delta;
            snappedV = line;
            cand.apply(line);
          }
        }
      }

      const hCandidates = [
        { val: top, apply: (line) => (snappedY = line) },
        { val: cy, apply: (line) => (snappedY = line - h / 2) },
        { val: bottom, apply: (line) => (snappedY = line - h) }
      ];

      let bestDeltaH = SNAP_DISTANCE + 1;
      for (const cand of hCandidates) {
        for (const line of snapLines.horizontal) {
          const delta = Math.abs(cand.val - line);
          if (delta <= SNAP_DISTANCE && delta < bestDeltaH) {
            bestDeltaH = delta;
            snappedH = line;
            cand.apply(line);
          }
        }
      }

      snappedX = Math.max(0, Math.min(CANVAS_WIDTH - w, snappedX));
      snappedY = Math.max(0, Math.min(CANVAS_HEIGHT - h, snappedY));

      clearSnapGuides();
      if (snappedV != null) addSnapGuideVertical(snappedV);
      if (snappedH != null) addSnapGuideHorizontal(snappedH);

      return {
        x: Math.round(snappedX),
        y: Math.round(snappedY)
      };
    }

    function renderCanvas() {
      const page = getCurrentPage();
      const existingGrid = canvas.querySelector(".canvas-grid");
      const existingGuides = canvas.querySelectorAll(".snap-guide");
      canvas.innerHTML = "";
      if (existingGrid) canvas.appendChild(existingGrid);
      existingGuides.forEach((g) => canvas.appendChild(g));
      if (!page) return;

      for (const widget of page.widgets) {
        const el = document.createElement("div");
        el.className = "widget";
        el.style.left = widget.x + "px";
        el.style.top = widget.y + "px";
        el.style.width = widget.width + "px";
        el.style.height = widget.height + "px";
        el.dataset.id = widget.id;

        if (widget.id === selectedWidgetId) {
          el.classList.add("active");
        }

        const type = (widget.type || "").toLowerCase();
        const props = widget.props || {};

        if (type === "icon") {
          const code = (props.code || "").trim().toUpperCase();
          const sizeManual = parseInt(props.size || 40, 10) || 40;
          const hex = code && code.match(/^F[0-9A-F]{4}$/i) ? code : "F0595";
          const cp = 0xf0000 + parseInt(hex.slice(1), 16);
          const ch = String.fromCodePoint(cp);

          const color = props.color || "black";
          const colorStyle =
            color === "white"
              ? "#ffffff"
              : color === "gray"
              ? "#aaaaaa"
              : "#000000";

          const fit = !!props.fit_icon_to_frame;
          el.classList.add("mdi-icon-preview");
          el.style.fontFamily = "MDI, system-ui, -apple-system, BlinkMacSystemFont, -sans-serif";
          el.style.lineHeight = "1";
          el.style.color = colorStyle;

          if (fit) {
            const padding = 4;
            const maxW = Math.max(8, (widget.width || 0) - padding * 2);
            const maxH = Math.max(8, (widget.height || 0) - padding * 2);
            const size = Math.max(8, Math.min(maxW, maxH));
            el.style.display = "flex";
            el.style.alignItems = "center";
            el.style.justifyContent = "center";
            el.style.fontSize = size + "px";
          } else {
            el.style.fontSize = sizeManual + "px";
          }

          el.textContent = ch;
        } else if (type === "shape_rect" || type === "shape_circle" || type === "line") {
          const color = props.color || "black";
          const borderWidth = parseInt(props.border_width != null ? props.border_width : 1, 10);
          const fill = !!props.fill;
          const opacityVal = parseInt(props.opacity != null ? props.opacity : 100, 10);
          const opacity = Math.max(0, Math.min(100, isNaN(opacityVal) ? 100 : opacityVal)) / 100;
          const strokeWidthVal = parseInt(
            props.stroke_width != null ? props.stroke_width : (borderWidth || 1),
            10
          );
          const strokeWidth = Math.max(1, isNaN(strokeWidthVal) ? 1 : strokeWidthVal);

          const colorValue =
            color === "white"
              ? "#ffffff"
              : color === "gray"
              ? "#aaaaaa"
              : "#000000";

          if (type === "shape_rect") {
            el.style.boxSizing = "border-box";
            el.style.border = borderWidth > 0 ? borderWidth + "px solid " + colorValue : "none";
            el.style.backgroundColor = fill ? colorValue : "transparent";
            el.style.opacity = fill ? opacity : 1;
          } else if (type === "shape_circle") {
            el.style.boxSizing = "border-box";
            el.style.borderRadius = "999px";
            el.style.border = borderWidth > 0 ? borderWidth + "px solid " + colorValue : "none";
            el.style.backgroundColor = fill ? colorValue : "transparent";
            el.style.opacity = fill ? opacity : 1;
          } else if (type === "line") {
            el.style.boxSizing = "border-box";
            el.style.height = strokeWidth + "px";
            el.style.width = (widget.width || 80) + "px";
            el.style.backgroundColor = colorValue;
          }
        } else if (type === "image") {
          const path = props.path || "";
          const invert = !!props.invert;
          
          el.style.boxSizing = "border-box";
          el.style.border = "2px dashed #aaaaaa";
          el.style.backgroundColor = "#f5f5f5";
          el.style.display = "flex";
          el.style.alignItems = "center";
          el.style.justifyContent = "center";
          el.style.overflow = "hidden";
          
          if (path) {
            const filename = path.split("/").pop();
            
            el.innerHTML = "";
            
            const img = document.createElement("img");
            img.style.maxWidth = "100%";
            img.style.maxHeight = "100%";
            img.style.objectFit = "contain";
            
            if (invert) {
              img.style.filter = "invert(1)";
            }
            
            img.onerror = () => {
              el.innerHTML = "<div style='text-align:center;color:#666;font-size:11px;padding:8px;line-height:1.4;'>" +
                "🖼️<br/><strong>" + filename + "</strong><br/>" +
                "<span style='color:#999;font-size:9px;'>" + 
                (invert ? "(inverted) " : "") + 
                widget.width + "×" + widget.height + "px<br/>" +
                "File not found or not accessible</span></div>";
            };
            
            img.onload = () => {
              const overlay = document.createElement("div");
              overlay.style.position = "absolute";
              overlay.style.bottom = "2px";
              overlay.style.right = "2px";
              overlay.style.background = "rgba(0,0,0,0.6)";
              overlay.style.color = "white";
              overlay.style.padding = "2px 4px";
              overlay.style.fontSize = "8px";
              overlay.style.borderRadius = "2px";
              overlay.textContent = filename + " • " + widget.width + "×" + widget.height + "px";
              el.style.position = "relative";
              el.appendChild(overlay);
            };
            
            const proxyUrl = "/api/reterminal_dashboard/image_proxy?path=" + encodeURIComponent(path);
            img.src = proxyUrl;
            el.appendChild(img);
          } else {
            const placeholder = document.createElement("div");
            placeholder.style.textAlign = "center";
            placeholder.style.color = "#aaa";
            placeholder.style.fontSize = "11px";
            placeholder.innerHTML = "🖼️<br/>Image Widget<br/><span style='font-size:9px;color:#ccc;'>Enter path in properties →</span>";
            el.appendChild(placeholder);
          }
        } else if (type === "datetime") {
          const format = props.format || "time_date";
          const timeFontSize = props.time_font_size || 28;
          const dateFontSize = props.date_font_size || 16;
          const color = props.color || "black";
          const colorStyle =
            color === "white"
              ? "#ffffff"
              : color === "gray"
              ? "#aaaaaa"
              : "#000000";
          
          const now = new Date();
          const timeStr = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
          const dateStr = now.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
          
          el.style.display = "flex";
          el.style.flexDirection = "column";
          el.style.justifyContent = "center";
          el.style.alignItems = "center";
          el.style.color = colorStyle;
          
          if (format === "time_only") {
            const timeEl = document.createElement("div");
            timeEl.style.fontSize = timeFontSize + "px";
            timeEl.style.fontWeight = "bold";
            timeEl.textContent = timeStr;
            el.appendChild(timeEl);
          } else if (format === "date_only") {
            const dateEl = document.createElement("div");
            dateEl.style.fontSize = dateFontSize + "px";
            dateEl.textContent = dateStr;
            el.appendChild(dateEl);
          } else {
            const timeEl = document.createElement("div");
            timeEl.style.fontSize = timeFontSize + "px";
            timeEl.style.fontWeight = "bold";
            timeEl.textContent = timeStr;
            const dateEl = document.createElement("div");
            dateEl.style.fontSize = dateFontSize + "px";
            dateEl.style.marginTop = "2px";
            dateEl.textContent = dateStr;
            el.appendChild(timeEl);
            el.appendChild(dateEl);
          }
        } else if (type === "progress_bar") {
          const entityId = widget.entity_id || "";
          const label = widget.title || "";
          const showLabel = props.show_label !== false;
          const showPercentage = props.show_percentage !== false;
          const barHeight = props.bar_height || 15;
          const borderWidth = props.border_width || 1;
          const color = props.color || "black";
          const colorStyle =
            color === "white"
              ? "#ffffff"
              : color === "gray"
              ? "#aaaaaa"
              : "#000000";
          
          let progress = 50;
          if (hasHaBackend() && entityId) {
            const state = getEntityState(entityId);
            if (state !== null && state !== undefined) {
              const val = parseFloat(state);
              if (!isNaN(val)) {
                progress = Math.max(0, Math.min(100, val));
              }
            }
          }
          
          el.style.display = "flex";
          el.style.flexDirection = "column";
          el.style.justifyContent = "center";
          el.style.gap = "4px";
          el.style.color = colorStyle;
          
          if (showLabel && (label || showPercentage)) {
            const labelRow = document.createElement("div");
            labelRow.style.display = "flex";
            labelRow.style.justifyContent = "space-between";
            labelRow.style.alignItems = "center";
            labelRow.style.fontSize = "12px";
            labelRow.style.paddingBottom = "2px";
            
            if (label) {
              const labelSpan = document.createElement("span");
              labelSpan.textContent = label;
              labelRow.appendChild(labelSpan);
            }
            
            if (showPercentage) {
              const pctSpan = document.createElement("span");
              pctSpan.textContent = Math.round(progress) + "%";
              labelRow.appendChild(pctSpan);
            }
            
            el.appendChild(labelRow);
          }
          
          const barContainer = document.createElement("div");
          barContainer.style.width = "100%";
          barContainer.style.height = barHeight + "px";
          barContainer.style.border = borderWidth + "px solid " + colorStyle;
          barContainer.style.borderRadius = "2px";
          barContainer.style.position = "relative";
          barContainer.style.overflow = "hidden";
          barContainer.style.backgroundColor = color === "white" ? "#000" : "#fff";
          
          const barFill = document.createElement("div");
          barFill.style.width = progress + "%";
          barFill.style.height = "100%";
          barFill.style.backgroundColor = colorStyle;
          barFill.style.transition = "width 0.3s ease";
          
          barContainer.appendChild(barFill);
          el.appendChild(barContainer);
        } else if (type === "battery_icon") {
          const entityId = widget.entity_id || "";
          const size = parseInt(props.size || 48, 10) || 48;
          const color = props.color || "black";
          const colorStyle =
            color === "white"
              ? "#ffffff"
              : color === "gray"
              ? "#aaaaaa"
              : "#000000";
          
          let batteryLevel = 75;
          if (hasHaBackend() && entityId) {
            const state = getEntityState(entityId);
            if (state !== null && state !== undefined) {
              const val = parseFloat(state);
              if (!isNaN(val)) {
                batteryLevel = Math.max(0, Math.min(100, val));
              }
            }
          }
          
          let iconCode = "F0079";
          if (batteryLevel <= 10) iconCode = "F007A";
          else if (batteryLevel <= 20) iconCode = "F007B";
          else if (batteryLevel <= 30) iconCode = "F007C";
          else if (batteryLevel <= 40) iconCode = "F007D";
          else if (batteryLevel <= 50) iconCode = "F007E";
          else if (batteryLevel <= 60) iconCode = "F007F";
          else if (batteryLevel <= 70) iconCode = "F0080";
          else if (batteryLevel <= 80) iconCode = "F0081";
          else if (batteryLevel <= 90) iconCode = "F0082";
          
          const cp = 0xf0000 + parseInt(iconCode.slice(1), 16);
          const ch = String.fromCodePoint(cp);
          
          el.classList.add("mdi-icon-preview");
          el.style.fontFamily = "MDI, system-ui, -apple-system, BlinkMacSystemFont, -sans-serif";
          el.style.lineHeight = "1";
          el.style.color = colorStyle;
          el.style.display = "flex";
          el.style.flexDirection = "column";
          el.style.alignItems = "center";
          el.style.justifyContent = "center";
          el.style.fontSize = size + "px";
          el.textContent = ch;
          
          const pctLabel = document.createElement("div");
          pctLabel.style.fontSize = "10px";
          pctLabel.style.marginTop = "2px";
          pctLabel.textContent = Math.round(batteryLevel) + "%";
          el.appendChild(pctLabel);
        } else {
          const color = props.color || "black";
          const opacityVal = parseInt(props.opacity != null ? props.opacity : 100, 10);
          const opacity = Math.max(0, Math.min(100, isNaN(opacityVal) ? 100 : opacityVal)) / 100;

          const colorStyle =
            color === "white"
              ? "#ffffff"
              : color === "gray"
              ? "#aaaaaa"
              : "#000000";

          if (type === "sensor_text") {
            const entityId = widget.entity_id || "";
            const label = widget.title || "";
            const valueFormat = props.value_format || "value_only";
            const labelFontSize = props.label_font_size || 14;
            const valueFontSize = props.value_font_size || 20;
            const fontFamily = props.font_family || "Inter";
            
            let displayValue = "23.5°C";
            
            if (hasHaBackend() && entityId) {
              const state = getEntityState(entityId);
              console.log(`[Canvas] Rendering sensor_text: entity=${entityId}, state=${state}, label=${label}, format=${valueFormat}`);
              
              if (state !== null && state !== undefined) {
                displayValue = String(state);
              } else {
                displayValue = "Loading...";
              }
            }
            
            const body = document.createElement("div");
            body.style.color = colorStyle;
            body.style.opacity = opacity;
            body.style.fontFamily = fontFamily + ", sans-serif";
            
            if (valueFormat === "label_value" && label) {
              body.style.display = "flex";
              body.style.alignItems = "baseline";
              body.style.gap = "4px";
              
              const labelSpan = document.createElement("span");
              labelSpan.style.fontSize = labelFontSize + "px";
              labelSpan.textContent = label + ":";
              
              const valueSpan = document.createElement("span");
              valueSpan.style.fontSize = valueFontSize + "px";
              valueSpan.textContent = displayValue;
              
              body.appendChild(labelSpan);
              body.appendChild(valueSpan);
            } else if (valueFormat === "label_newline_value" && label) {
              body.style.display = "flex";
              body.style.flexDirection = "column";
              body.style.gap = "2px";
              
              const labelDiv = document.createElement("div");
              labelDiv.style.fontSize = labelFontSize + "px";
              labelDiv.textContent = label;
              
              const valueDiv = document.createElement("div");
              valueDiv.style.fontSize = valueFontSize + "px";
              valueDiv.textContent = displayValue;
              
              body.appendChild(labelDiv);
              body.appendChild(valueDiv);
            } else {
              body.style.fontSize = valueFontSize + "px";
              body.textContent = displayValue;
            }
            
            el.appendChild(body);
          } else {
            const fontSize = props.font_size || 16;
            const fontFamily = props.font_family || "Inter";
            const body = document.createElement("div");
            body.style.fontSize = fontSize + "px";
            body.style.fontFamily = fontFamily + ", sans-serif";
            body.style.color = colorStyle;
            body.style.opacity = opacity;
            body.textContent = props.text || widget.title || "Text";
            el.appendChild(body);
          }
        }

        const handle = document.createElement("div");
        handle.className = "widget-resize-handle";
        el.appendChild(handle);

        el.addEventListener("mousedown", (ev) => onWidgetMouseDown(ev, widget.id));
        canvas.appendChild(el);
      }
    }

    function renderPropertiesPanel() {
      const panel = propertiesPanel;
      panel.innerHTML = "";

      const widget = selectedWidgetId ? widgetsById.get(selectedWidgetId) : null;
      if (!widget) {
        const info = document.createElement("div");
        info.className = "field";
        info.innerHTML =
          '<span style="font-size:9px;color:var(--muted);">Select a widget on the canvas to edit its properties.</span>';
        panel.appendChild(info);
        return;
      }

      const type = (widget.type || "").toLowerCase();
      widget.props = widget.props || {};

      function addLabeledInput(label, typeAttr, value, onChange) {
        const wrap = document.createElement("div");
        wrap.className = "field";
        const lbl = document.createElement("div");
        lbl.className = "prop-label";
        lbl.textContent = label;
        const inp = document.createElement("input");
        inp.className = "prop-input";
        inp.type = typeAttr;
        inp.value = value != null ? value : "";
        inp.addEventListener("input", () => {
          onChange(inp.value);
          scheduleSnippetUpdate();
        });
        wrap.appendChild(lbl);
        wrap.appendChild(inp);
        panel.appendChild(wrap);
        return inp;
      }

      function addSelect(label, value, options, onChange) {
        const wrap = document.createElement("div");
        wrap.className = "field";
        const lbl = document.createElement("div");
        lbl.className = "prop-label";
        lbl.textContent = label;
        const sel = document.createElement("select");
        sel.className = "prop-input";
        options.forEach((optVal) => {
          const opt = document.createElement("option");
          opt.value = optVal;
          opt.textContent = optVal;
          if (optVal === value) opt.selected = true;
          sel.appendChild(opt);
        });
        sel.addEventListener("change", () => {
          onChange(sel.value);
          scheduleSnippetUpdate();
        });
        wrap.appendChild(lbl);
        wrap.appendChild(sel);
        panel.appendChild(wrap);
        return sel;
      }

      addLabeledInput("Position X", "number", widget.x, (v) => {
        widget.x = parseInt(v || "0", 10) || 0;
        renderCanvas();
      });
      addLabeledInput("Position Y", "number", widget.y, (v) => {
        widget.y = parseInt(v || "0", 10) || 0;
        renderCanvas();
      });

      if (type === "line") {
        addLabeledInput("dx (line width)", "number", widget.width, (v) => {
          widget.width = parseInt(v || "0", 10) || 0;
          renderCanvas();
        });
        addLabeledInput("dy (line height)", "number", widget.height, (v) => {
          widget.height = parseInt(v || "0", 10) || 0;
          renderCanvas();
        });
      } else {
        addLabeledInput("Width", "number", widget.width, (v) => {
          widget.width = parseInt(v || "0", 10) || 0;
          renderCanvas();
        });
        addLabeledInput("Height", "number", widget.height, (v) => {
          widget.height = parseInt(v || "0", 10) || 0;
          renderCanvas();
        });
      }

      if (type === "icon") {
        const fitWrap = document.createElement("div");
        fitWrap.className = "field";
        const fitLbl = document.createElement("div");
        fitLbl.className = "prop-label";
        fitLbl.textContent = "Fit icon to frame";
        const fitCb = document.createElement("input");
        fitCb.type = "checkbox";
        fitCb.checked = !!widget.props.fit_icon_to_frame;
        fitCb.addEventListener("change", () => {
          widget.props.fit_icon_to_frame = fitCb.checked;
          renderCanvas();
          scheduleSnippetUpdate();
        });
        fitWrap.appendChild(fitLbl);
        fitWrap.appendChild(fitCb);
        panel.appendChild(fitWrap);

        const iconPickerData = [
          // Battery icons
          { code: "F0079", name: "battery-outline" },
          { code: "F007A", name: "battery-10" },
          { code: "F007B", name: "battery-20" },
          { code: "F007C", name: "battery-30" },
          { code: "F007D", name: "battery-40" },
          { code: "F007E", name: "battery-50" },
          { code: "F007F", name: "battery-60" },
          { code: "F0080", name: "battery-70" },
          { code: "F0081", name: "battery-80" },
          { code: "F0082", name: "battery-90" },
          { code: "F0083", name: "battery-100" },
          // Weather icons
          { code: "F0591", name: "weather-sunny" },
          { code: "F0594", name: "weather-night-clear" },
          { code: "F0595", name: "weather-cloudy" },
          { code: "F0599", name: "weather-partly-cloudy" },
          { code: "F0596", name: "weather-rainy" },
          { code: "F0590", name: "weather-snowy" },
          { code: "F192D", name: "weather-snowy-heavy" },
          { code: "F192C", name: "weather-fog" },
          { code: "F067E", name: "weather-night" },
          { code: "F0598", name: "weather-lightning" },
          { code: "F0597", name: "weather-windy" },
          { code: "F0D9B", name: "cloud" },
          { code: "F06A1", name: "weather-pouring" },
          { code: "F0F2F", name: "weather-windy-variant" },
          { code: "F0F31", name: "weather-night-partly-cloudy" },
          { code: "F0F33", name: "weather-tornado" },
          { code: "F0593", name: "weather-hurricane" },
          { code: "F0E6E", name: "weather-hail" },
          { code: "F067F", name: "weather-lightning-rainy" },
          { code: "F0F30", name: "weather-dust" },
          { code: "F059D", name: "white-balance-sunny" },
          { code: "F0F32", name: "weather-snowy-rainy" },
          { code: "F0E6D", name: "weather-partly-rainy" },
          { code: "F0F34", name: "weather-sunset" },
          // Connectivity & Power
          { code: "F050F", name: "power-plug" },
          { code: "F043C", name: "wifi" },
          { code: "F15FA", name: "signal-variant" },
          // Sensors
          { code: "F058C", name: "brightness-percent" },
          { code: "F09A1", name: "thermometer-lines" },
          { code: "F058E", name: "water-percent" },
          { code: "F042B", name: "weather-thermometer" },
          { code: "F05D6", name: "thermometer" },
          { code: "F010C", name: "thermometer" },
          { code: "F0E8B", name: "home-thermometer" },
          { code: "F10BF", name: "temperature-celsius" },
          { code: "F10C0", name: "temperature-fahrenheit" },
          { code: "F058E", name: "water-percent" },
          { code: "F1049", name: "air-humidifier" },
          { code: "F073F", name: "air-conditioner" },
          { code: "F0E51", name: "radiator" },
          { code: "F0238", name: "fan" },
          { code: "F1025", name: "fan-off" },
          { code: "F0F2E", name: "weather-windy" },
          { code: "F0F3D", name: "weather-dust" },
          { code: "F1837", name: "air-filter" },
          { code: "F006E", name: "biohazard" },
          { code: "F050D", name: "fire" },
          { code: "F050F", name: "home" },
          { code: "F0510", name: "home-variant" },
          { code: "F06A1", name: "home-outline" },
          { code: "F15E6", name: "home-automation" },
          { code: "F0D8A", name: "home-floor-1" },
          { code: "F0D8B", name: "home-floor-2" },
          { code: "F0D8C", name: "home-floor-3" },
          { code: "F02E7", name: "bed" },
          { code: "F04B9", name: "sofa" },
          { code: "F070B", name: "door" },
          { code: "F081B", name: "door-open" },
          { code: "F081C", name: "door-closed" },
          { code: "F1359", name: "garage" },
          { code: "F135A", name: "garage-open" },
          { code: "F06B9", name: "gate" },
          { code: "F0E1E", name: "window-open" },
          { code: "F0E1D", name: "window-closed" },
          { code: "F1B3E", name: "window-shutter" },
          { code: "F1B3F", name: "window-shutter-open" },
          { code: "F0BCA", name: "stairs" },
          { code: "F07FD", name: "balcony" },
          { code: "F112A", name: "floor-plan" },
          { code: "F06A0", name: "roof" },
          { code: "F1A2F", name: "fence" },
          { code: "F099D", name: "car" },
          { code: "F008A", name: "lightbulb" },
          { code: "F0335", name: "lightbulb-on" },
          { code: "F0336", name: "lightbulb-off" },
          { code: "F06E8", name: "lightbulb-outline" },
          { code: "F1D9F", name: "ceiling-light" },
          { code: "F0769", name: "lamp" },
          { code: "F1433", name: "lamp-outline" },
          { code: "F17D3", name: "floor-lamp" },
          { code: "F095C", name: "desk-lamp" },
          { code: "F0F5B", name: "led-on" },
          { code: "F0F5C", name: "led-off" },
          { code: "F0F5D", name: "led-outline" },
          { code: "F1020", name: "led-strip" },
          { code: "F1021", name: "led-strip-variant" },
          { code: "F06C5", name: "lava-lamp" },
          { code: "F0769", name: "outdoor-lamp" },
          { code: "F1311", name: "wall-sconce" },
          { code: "F1312", name: "wall-sconce-flat" },
          { code: "F1313", name: "wall-sconce-round" },
          { code: "F1C5C", name: "coach-lamp" },
          { code: "F057F", name: "power" },
          { code: "F0580", name: "power-off" },
          { code: "F0425", name: "check" },
          { code: "F0156", name: "close" },
          { code: "F0C4E", name: "toggle-switch" },
          { code: "F0C4F", name: "toggle-switch-off" },
          { code: "F0493", name: "cog" },
          { code: "F08BB", name: "settings" },
          { code: "F0419", name: "menu" },
          { code: "F035C", name: "dots-vertical" },
          { code: "F01D9", name: "dots-horizontal" },
          { code: "F0142", name: "plus" },
          { code: "F0374", name: "minus" },
          { code: "F0140", name: "pencil" },
          { code: "F0A1A", name: "delete" },
          { code: "F0835", name: "refresh" },
          { code: "F02E6", name: "backup-restore" },
          { code: "F0193", name: "content-save" },
          { code: "F0C55", name: "tray-arrow-up" },
          { code: "F0C56", name: "tray-arrow-down" },
          { code: "F06C9", name: "lock" },
          { code: "F033E", name: "lock-open" },
          { code: "F0FC7", name: "shield-home" },
          { code: "F0780", name: "shield" },
          { code: "F0143", name: "bell" },
          { code: "F156C", name: "bell-alert" },
          { code: "F0029", name: "alarm-light" },
          { code: "F0024", name: "alert" },
          { code: "F0026", name: "alert-circle" },
          { code: "F02DC", name: "camera" },
          { code: "F1900", name: "cctv" },
          { code: "F07F5", name: "security" },
          { code: "F111C", name: "motion-sensor" },
          { code: "F0D39", name: "motion-sensor-off" },
          { code: "F0D95", name: "smoke-detector" },
          { code: "F11BD", name: "smoke-detector-alert" },
          { code: "F1A73", name: "fire-alert" },
          { code: "F1A74", name: "fire-extinguisher" },
          { code: "F11C6", name: "sprinkler" },
          { code: "F11C7", name: "sprinkler-variant" },
          { code: "F06E8", name: "play" },
          { code: "F03E4", name: "pause" },
          { code: "F04DB", name: "stop" },
          { code: "F04AE", name: "skip-next" },
          { code: "F04AD", name: "skip-previous" },
          { code: "F0EE0", name: "volume-high" },
          { code: "F075E", name: "volume-off" },
          { code: "F0765", name: "music" },
          { code: "F040A", name: "speaker" },
          { code: "F0794", name: "television" },
          { code: "F0322", name: "wifi" },
          { code: "F092F", name: "wifi-off" },
          { code: "F05A9", name: "bluetooth" },
          { code: "F0B43", name: "spotify" },
          { code: "F02C3", name: "youtube" },
          { code: "F11FC", name: "netflix" },
          { code: "F0057", name: "apple" },
          { code: "F040B", name: "cast" },
          { code: "F0239", name: "clock" },
          { code: "F0453", name: "calendar" },
          { code: "F08D0", name: "timer" },
          { code: "F0024", name: "alarm" },
          { code: "F14E4", name: "radio" },
          { code: "F036D", name: "microphone" },
          { code: "F036E", name: "microphone-off" },
          { code: "F0A48", name: "robot-vacuum" },
          { code: "F070D", name: "washing-machine" },
          { code: "F0232", name: "fridge" },
          { code: "F0CD6", name: "coffee-maker" },
          { code: "F1A42", name: "toaster" },
          { code: "F06D3", name: "microwave" },
          { code: "F0246", name: "stove" },
          { code: "F13E2", name: "oven" },
          { code: "F0EFB", name: "dishwasher" },
          { code: "F0A49", name: "vacuum" },
          { code: "F0663", name: "iron" },
          { code: "F1C48", name: "iron-outline" },
          { code: "F04B0", name: "blender" },
          { code: "F0EEF", name: "kettle" },
          { code: "F1006", name: "kettle-steam" },
          { code: "F02E3", name: "scale" },
          { code: "F0F8A", name: "scale-bathroom" },
          { code: "F11A1", name: "hair-dryer" },
          { code: "F11A2", name: "hair-dryer-outline" },
          { code: "F070C", name: "water-heater" },
          { code: "F1A6C", name: "water-pump" },
          { code: "F070E", name: "water-off" },
          { code: "F058A", name: "water" },
          { code: "F1436", name: "trash-can" },
          { code: "F0A79", name: "recycle" },
          { code: "F07E4", name: "battery" },
          { code: "F07E2", name: "battery-charging" },
          { code: "F12A1", name: "battery-50" },
          { code: "F0079", name: "battery-10" },
          { code: "F1A2E", name: "battery-high" },
          { code: "F007A", name: "battery-low" },
          { code: "F053D", name: "speedometer" },
          { code: "F0316", name: "gauge" },
          { code: "F07D1", name: "chart-line" },
          { code: "F01D7", name: "chart-bar" },
          { code: "F0127", name: "chart-donut" },
          { code: "F07E0", name: "chart-pie" },
          { code: "F1460", name: "chart-timeline" },
          { code: "F0E4C", name: "finance" },
          { code: "F0356", name: "currency-usd" },
          { code: "F033A", name: "currency-eur" },
          { code: "F02C1", name: "percent" },
          { code: "F0D7D", name: "poll" },
          { code: "F0125", name: "counter" },
          { code: "F1A5D", name: "meter-electric" },
          { code: "F0141", name: "arrow-up" },
          { code: "F0045", name: "arrow-down" },
          { code: "F004D", name: "arrow-left" },
          { code: "F0054", name: "arrow-right" },
          { code: "F0143", name: "chevron-up" },
          { code: "F0140", name: "chevron-down" },
          { code: "F0141", name: "chevron-left" },
          { code: "F0142", name: "chevron-right" },
          { code: "F035F", name: "menu-up" },
          { code: "F0360", name: "menu-down" },
          { code: "F035D", name: "menu-left" },
          { code: "F035E", name: "menu-right" },
          { code: "F02D7", name: "navigation" },
          { code: "F0E80", name: "compass" },
          { code: "F036C", name: "map" },
          { code: "F012C", name: "circle" },
          { code: "F0765", name: "record" },
          { code: "F0C92", name: "checkbox-marked" },
          { code: "F0C91", name: "checkbox-blank" },
          { code: "F0134", name: "radiobox-marked" },
          { code: "F0135", name: "radiobox-blank" },
          { code: "F0E1F", name: "star" },
          { code: "F0E20", name: "star-outline" },
          { code: "F029B", name: "heart" },
          { code: "F029C", name: "heart-outline" },
          { code: "F0765", name: "thumb-up" },
          { code: "F0766", name: "thumb-down" },
          { code: "F0028", name: "information" },
          { code: "F0625", name: "help-circle" },
          { code: "F05D6", name: "comment" },
          { code: "F043C", name: "home-assistant" },
          { code: "F07D0", name: "raspberry-pi" },
          { code: "F01BC", name: "code-tags" },
          { code: "F0A2F", name: "satellite-variant" },
          { code: "F06DC", name: "router-wireless" },
          { code: "F0317", name: "ethernet" },
          { code: "F0318", name: "cable-data" },
          { code: "F05A7", name: "webhook" },
          { code: "F0E03", name: "api" },
          { code: "F0DB3", name: "cloud-sync" },
          { code: "F02C5", name: "cloud" },
          { code: "F0DB2", name: "cloud-upload" },
          { code: "F0DB1", name: "cloud-download" },
          { code: "F019A", name: "download" },
          { code: "F0552", name: "upload" },
          { code: "F0625", name: "lan" },
          { code: "F0DA7", name: "ip-network" },
          { code: "F132D", name: "nas" },
          { code: "F0A0C", name: "server" },
          { code: "F0A0D", name: "server-network" },
          { code: "F0FB1", name: "air-purifier" },
          { code: "F104A", name: "humidifier" },
          { code: "F104B", name: "dehumidifier" },
          { code: "F181F", name: "air-horn" },
          { code: "F0697", name: "printer" },
          { code: "F042A", name: "scanner" },
          { code: "F0AF9", name: "shredder" },
          { code: "F0EF9", name: "paper-cut-vertical" },
          { code: "F06D0", name: "monitor" },
          { code: "F0322", name: "laptop" },
          { code: "F0CEE", name: "tablet" },
          { code: "F0C5F", name: "cellphone" },
          { code: "F0A5A", name: "phone" },
          { code: "F06E1", name: "keyboard" },
          { code: "F06E2", name: "mouse" },
          { code: "F0A5F", name: "remote" },
          { code: "F0A63", name: "gamepad" },
          { code: "F0A64", name: "controller-classic" },
          { code: "F1358", name: "glasses" },
          { code: "F0E31", name: "headphones" },
          { code: "F0E50", name: "sprinkler" },
          { code: "F0F5E", name: "water-pump" },
          { code: "F100A", name: "watering-can" },
          { code: "F0571", name: "flower" },
          { code: "F0C93", name: "tree" },
          { code: "F0C94", name: "palm-tree" },
          { code: "F0534", name: "grass" },
          { code: "F0D9F", name: "pine-tree" },
          { code: "F13ED", name: "grill" },
          { code: "F1468", name: "grill-outline" },
          { code: "F0232", name: "pool" },
          { code: "F0667", name: "hot-tub" },
          { code: "F1A3B", name: "patio-heater" },
          { code: "F17D1", name: "outdoor-lighting" },
          { code: "F0F1D", name: "mailbox" },
          { code: "F0A17", name: "solar-panel" },
          { code: "F0A18", name: "solar-panel-large" },
          { code: "F0A19", name: "solar-power" },
          { code: "F110D", name: "wind-turbine" },
          { code: "F0903", name: "transmission-tower" },
          { code: "F140B", name: "lightning-bolt" },
          { code: "F050E", name: "flash" },
          { code: "F0E9F", name: "flash-outline" },
          { code: "F0738", name: "ev-station" },
          { code: "F1873", name: "ev-plug-type1" },
          { code: "F1874", name: "ev-plug-type2" },
          { code: "F007F", name: "battery-charging-80" },
          { code: "F0580", name: "power-plug" },
          { code: "F06A5", name: "power-socket" },
          { code: "F1844", name: "power-socket-eu" },
          { code: "F1845", name: "power-socket-uk" },
          { code: "F1846", name: "power-socket-us" },
          { code: "F0C5B", name: "fuel" },
          { code: "F1344", name: "gas-station" },
          { code: "F1022", name: "propane-tank" },
          { code: "F0765", name: "heart-pulse" },
          { code: "F0A38", name: "medical-bag" },
          { code: "F0A39", name: "hospital" },
          { code: "F050A", name: "pill" },
          { code: "F0E2E", name: "thermometer-lines" },
          { code: "F1626", name: "face-mask" },
          { code: "F0B48", name: "allergy" },
          { code: "F0BF9", name: "sleep" },
          { code: "F0BFA", name: "sleep-off" },
          { code: "F06F7", name: "run" },
          { code: "F0B56", name: "walk" },
          { code: "F151F", name: "yoga" },
          { code: "F04D7", name: "dumbbell" },
          { code: "F1A91", name: "weight-kilogram" },
          { code: "F06F4", name: "scale-balance" },
          { code: "F0235", name: "file" },
          { code: "F0236", name: "file-document" },
          { code: "F0737", name: "folder" },
          { code: "F0770", name: "folder-open" },
          { code: "F0A0E", name: "briefcase" },
          { code: "F0238", name: "calendar-today" },
          { code: "F0ED0", name: "calendar-month" },
          { code: "F0C42", name: "note" },
          { code: "F0C43", name: "notebook" },
          { code: "F0C44", name: "clipboard" },
          { code: "F0765", name: "bookmark" },
          { code: "F0A2A", name: "tag" },
          { code: "F0765", name: "label" },
          { code: "F0239", name: "archive" },
          { code: "F013C", name: "email" },
          { code: "F036D", name: "message" },
          { code: "F036E", name: "chat" },
          { code: "F0EF5", name: "forum" },
          { code: "F0238", name: "send" },
          { code: "F11C8", name: "phone-ring" },
          { code: "F11C9", name: "phone-missed" },
          { code: "F05CB", name: "voicemail" },
          { code: "F06A2", name: "video" },
          { code: "F06A3", name: "video-off" },
          { code: "F03CB", name: "account" },
          { code: "F0806", name: "account-group" },
          { code: "F1502", name: "account-multiple" },
          { code: "F0765", name: "contacts" },
          { code: "F0765", name: "badge-account" },
          { code: "F0B7F", name: "human-greeting" }
        ];

        const iconPickerWrap = document.createElement("div");
        iconPickerWrap.className = "field";
        const iconPickerLbl = document.createElement("div");
        iconPickerLbl.className = "prop-label";
        iconPickerLbl.textContent = "Quick icon picker (visual preview)";
        
        const iconPickerSelect = document.createElement("select");
        iconPickerSelect.className = "select";
        iconPickerSelect.style.fontFamily = "MDI, monospace, system-ui";
        iconPickerSelect.style.fontSize = "16px";
        iconPickerSelect.style.lineHeight = "1.5";
        
        const placeholderOpt = document.createElement("option");
        placeholderOpt.value = "";
        placeholderOpt.textContent = "-- Select icon --";
        placeholderOpt.style.fontFamily = "system-ui, -apple-system, BlinkMacSystemFont, sans-serif";
        iconPickerSelect.appendChild(placeholderOpt);
        
        iconPickerData.forEach(icon => {
          const opt = document.createElement("option");
          opt.value = icon.code;
          const cp = 0xf0000 + parseInt(icon.code.slice(1), 16);
          const glyph = String.fromCodePoint(cp);
          opt.textContent = glyph + "  " + icon.code;
          opt.style.fontFamily = "MDI, monospace, system-ui";
          iconPickerSelect.appendChild(opt);
        });
        
        const currentCode = (widget.props.code || "F0595").toUpperCase();
        const matchingIcon = iconPickerData.find(i => i.code === currentCode);
        if (matchingIcon) {
          iconPickerSelect.value = matchingIcon.code;
        }
        
        iconPickerSelect.addEventListener("change", () => {
          const selectedCode = iconPickerSelect.value;
          if (selectedCode) {
            widget.props.code = selectedCode;
            renderCanvas();
            renderPropertiesPanel();
            scheduleSnippetUpdate();
          }
        });
        
        iconPickerWrap.appendChild(iconPickerLbl);
        iconPickerWrap.appendChild(iconPickerSelect);
        panel.appendChild(iconPickerWrap);

        const moreIconsLink = document.createElement("div");
        moreIconsLink.style.fontSize = "12px";
        moreIconsLink.style.marginTop = "4px";
        moreIconsLink.style.marginBottom = "8px";
        moreIconsLink.style.color = "#666";
        moreIconsLink.innerHTML = 'Need more icons? Browse <a href="https://pictogrammers.com/library/mdi/icon/ " target="_blank" style="color: #03a9f4; text-decoration: none;">Pictogrammers MDI</a> and paste the Unicode below';
        panel.appendChild(moreIconsLink);

        addLabeledInput("MDI Unicode (Fxxxx)", "text", widget.props.code || "F0595", (v) => {
          const clean = (v || "").trim().toUpperCase().replace(/^0X/, "");
          if (/^F[0-9A-F]{4}$/i.test(clean)) {
            widget.props.code = clean;
          } else {
            widget.props.code = "F0595";
          }
          renderCanvas();
          scheduleSnippetUpdate();
        });

        addLabeledInput("Icon size (px)", "number", widget.props.size || 40, (v) => {
          let n = parseInt(v || "40", 10);
          if (Number.isNaN(n) || n < 8) n = 8;
          if (n > 260) n = 260;
          widget.props.size = n;
          renderCanvas();
          scheduleSnippetUpdate();
        });

        addSelect(
          "Font reference",
          widget.props.font_ref || "font_mdi_medium",
          ["font_mdi_medium", "font_mdi_large"],
          (val) => {
            widget.props.font_ref = val;
            renderCanvas();
            scheduleSnippetUpdate();
          }
        );

        addSelect("Icon color", widget.props.color || "black", ["black", "white", "gray"], (val) => {
          widget.props.color = val;
          renderCanvas();
          scheduleSnippetUpdate();
        });
      }

      if (type === "image") {
        const helpWrap = document.createElement("div");
        helpWrap.className = "field";
        helpWrap.style.fontSize = "9px";
        helpWrap.style.color = "var(--muted)";
        helpWrap.style.marginBottom = "8px";
        helpWrap.innerHTML = "💡 Enter ESPHome image path, e.g.:<br/>" +
          "<code style='background:#f0f0f0;padding:2px 4px;border-radius:2px;'>/config/esphome/images/photo.jpg</code><br/>" +
          "<span style='color:#4a9eff;'>ℹ️ Widget size controls ESPHome resize parameter</span>";
        panel.appendChild(helpWrap);
        
        addLabeledInput("Image path", "text", widget.props.path || "", (v) => {
          widget.props.path = v;
          renderCanvas();
        });
        
        const invertWrap = document.createElement("div");
        invertWrap.className = "field";
        const invertLbl = document.createElement("div");
        invertLbl.className = "prop-label";
        invertLbl.textContent = "Invert colors";
        const invertCb = document.createElement("input");
        invertCb.type = "checkbox";
        invertCb.checked = !!widget.props.invert;
        invertCb.addEventListener("change", () => {
          widget.props.invert = invertCb.checked;
          renderCanvas();
          scheduleSnippetUpdate();
        });
        invertWrap.appendChild(invertLbl);
        invertWrap.appendChild(invertCb);
        panel.appendChild(invertWrap);
        
        const fillWrap = document.createElement("div");
        fillWrap.className = "field";
        fillWrap.style.marginTop = "12px";
        
        const isFullScreen = (widget.x === 0 && widget.y === 0 && 
                             widget.width === CANVAS_WIDTH && 
                             widget.height === CANVAS_HEIGHT);
        
        const fillBtn = document.createElement("button");
        fillBtn.className = "btn " + (isFullScreen ? "btn-primary" : "btn-secondary") + " btn-full";
        fillBtn.textContent = isFullScreen ? "✓ Full Screen (click to restore)" : "⛶ Fill Screen";
        fillBtn.type = "button";
        fillBtn.title = isFullScreen ? "Restore to previous size" : "Resize image to fill entire screen";
        fillBtn.addEventListener("click", () => {
          if (widget.x === 0 && widget.y === 0 && 
              widget.width === CANVAS_WIDTH && 
              widget.height === CANVAS_HEIGHT) {
            widget.x = 50;
            widget.y = 50;
            widget.width = 200;
            widget.height = 150;
          } else {
            widget.x = 0;
            widget.y = 0;
            widget.width = CANVAS_WIDTH;
            widget.height = CANVAS_HEIGHT;
          }
          renderCanvas();
          renderPropertiesPanel();
          scheduleSnippetUpdate();
        });
        fillWrap.appendChild(fillBtn);
        panel.appendChild(fillWrap);
      }

      if (type === "online_image") {
        const helpWrap = document.createElement("div");
        helpWrap.className = "field";
        helpWrap.style.fontSize = "9px";
        helpWrap.style.color = "var(--muted)";
        helpWrap.style.marginBottom = "8px";
        helpWrap.innerHTML = "💡 Fetch remote images dynamically (Puppet support):<br/>" +
          "<code style='background:#f0f0f0;padding:2px 4px;border-radius:2px;'>https://example.com/camera/snapshot.jpg </code><br/>" +
          "<span style='color:#4a9eff;'>ℹ️ Images are downloaded at specified intervals</span>";
        panel.appendChild(helpWrap);
        
        addLabeledInput("Remote URL", "text", widget.props.url || "", (v) => {
          widget.props.url = v;
          renderCanvas();
          scheduleSnippetUpdate();
        });
        
        addLabeledInput("Update interval (seconds)", "number", widget.props.interval_s || 300, (v) => {
          widget.props.interval_s = parseInt(v, 10) || 300;
          renderCanvas();
          scheduleSnippetUpdate();
        });
      }

      if (type === "datetime") {
        addSelect(
          "Display format",
          widget.props.format || "time_date",
          ["time_date", "time_only", "date_only"],
          (val) => {
            widget.props.format = val;
            renderCanvas();
            scheduleSnippetUpdate();
          }
        );
        
        addLabeledInput("Time font size", "number", widget.props.time_font_size || 28, (v) => {
          widget.props.time_font_size = parseInt(v || "28", 10) || 28;
          renderCanvas();
          scheduleSnippetUpdate();
        });
        
        addLabeledInput("Date font size", "number", widget.props.date_font_size || 16, (v) => {
          widget.props.date_font_size = parseInt(v || "16", 10) || 16;
          renderCanvas();
          scheduleSnippetUpdate();
        });
        
        addSelect("Color", widget.props.color || "black", ["black", "white", "gray"], (val) => {
          widget.props.color = val;
          renderCanvas();
          scheduleSnippetUpdate();
        });
      }

      if (type === "progress_bar") {
        const entityWrap = document.createElement("div");
        entityWrap.className = "field";
        const entityLbl = document.createElement("div");
        entityLbl.className = "prop-label";
        entityLbl.textContent = "Entity ID (numeric sensor)";
        
        const entityRow = document.createElement("div");
        entityRow.style.display = "flex";
        entityRow.style.gap = "4px";
        
        const entityInput = document.createElement("input");
        entityInput.className = "prop-input";
        entityInput.type = "text";
        entityInput.value = widget.entity_id || "";
        entityInput.style.flex = "1";
        entityInput.addEventListener("input", () => {
          widget.entity_id = entityInput.value;
          if (hasHaBackend() && Object.keys(entityStatesCache).length === 0) {
            fetchEntityStates();
          }
          renderCanvas();
          scheduleSnippetUpdate();
        });
        
        const pickerBtn = document.createElement("button");
        pickerBtn.className = "btn btn-secondary";
        pickerBtn.textContent = "⋮⋮⋮";
        pickerBtn.style.padding = "5px 8px";
        pickerBtn.style.fontSize = "10px";
        pickerBtn.type = "button";
        pickerBtn.title = "Pick from Home Assistant entities";
        pickerBtn.addEventListener("click", () => {
          openEntityPickerForWidget(widget, entityInput);
        });
        
        entityRow.appendChild(entityInput);
        entityRow.appendChild(pickerBtn);
        entityWrap.appendChild(entityLbl);
        entityWrap.appendChild(entityRow);
        panel.appendChild(entityWrap);
        
        addLabeledInput("Label (optional)", "text", widget.title || "", (v) => {
          widget.title = v;
          renderCanvas();
          scheduleSnippetUpdate();
        });
        
        const showLabelWrap = document.createElement("div");
        showLabelWrap.className = "field";
        const showLabelLbl = document.createElement("div");
        showLabelLbl.className = "prop-label";
        showLabelLbl.textContent = "Show label row";
        const showLabelCb = document.createElement("input");
        showLabelCb.type = "checkbox";
        showLabelCb.checked = widget.props.show_label !== false;
        showLabelCb.addEventListener("change", () => {
          widget.props.show_label = showLabelCb.checked;
          renderCanvas();
          scheduleSnippetUpdate();
        });
        showLabelWrap.appendChild(showLabelLbl);
        showLabelWrap.appendChild(showLabelCb);
        panel.appendChild(showLabelWrap);
        
        const showPctWrap = document.createElement("div");
        showPctWrap.className = "field";
        const showPctLbl = document.createElement("div");
        showPctLbl.className = "prop-label";
        showPctLbl.textContent = "Show percentage";
        const showPctCb = document.createElement("input");
        showPctCb.type = "checkbox";
        showPctCb.checked = widget.props.show_percentage !== false;
        showPctCb.addEventListener("change", () => {
          widget.props.show_percentage = showPctCb.checked;
          renderCanvas();
          scheduleSnippetUpdate();
        });
        showPctWrap.appendChild(showPctLbl);
        showPctWrap.appendChild(showPctCb);
        panel.appendChild(showPctWrap);
        
        addLabeledInput("Bar height (px)", "number", widget.props.bar_height || 15, (v) => {
          widget.props.bar_height = parseInt(v || "15", 10) || 15;
          renderCanvas();
          scheduleSnippetUpdate();
        });
        
        addLabeledInput("Border width (px)", "number", widget.props.border_width || 1, (v) => {
          widget.props.border_width = parseInt(v || "1", 10) || 1;
          renderCanvas();
          scheduleSnippetUpdate();
        });
        
        addSelect("Color", widget.props.color || "black", ["black", "white", "gray"], (val) => {
          widget.props.color = val;
          renderCanvas();
          scheduleSnippetUpdate();
        });
      }

      if (type === "battery_icon") {
        const entityWrap = document.createElement("div");
        entityWrap.className = "field";
        const entityLbl = document.createElement("div");
        entityLbl.className = "prop-label";
        entityLbl.textContent = "Battery Entity ID";
        
        const entityRow = document.createElement("div");
        entityRow.style.display = "flex";
        entityRow.style.gap = "4px";
        
        const entityInput = document.createElement("input");
        entityInput.className = "prop-input";
        entityInput.type = "text";
        entityInput.value = widget.entity_id || "";
        entityInput.style.flex = "1";
        entityInput.addEventListener("input", () => {
          widget.entity_id = entityInput.value;
          if (hasHaBackend() && Object.keys(entityStatesCache).length === 0) {
            fetchEntityStates();
          }
          renderCanvas();
          scheduleSnippetUpdate();
        });
        
        const pickerBtn = document.createElement("button");
        pickerBtn.className = "btn btn-secondary";
        pickerBtn.textContent = "⋮⋮⋮";
        pickerBtn.style.padding = "5px 8px";
        pickerBtn.style.fontSize = "10px";
        pickerBtn.type = "button";
        pickerBtn.title = "Pick from Home Assistant entities";
        pickerBtn.addEventListener("click", () => {
          openEntityPickerForWidget(widget, entityInput);
        });
        
        entityRow.appendChild(entityInput);
        entityRow.appendChild(pickerBtn);
        entityWrap.appendChild(entityLbl);
        entityWrap.appendChild(entityRow);
        panel.appendChild(entityWrap);
        
        addLabeledInput("Icon size (px)", "number", widget.props.size || 48, (v) => {
          let n = parseInt(v || "48", 10);
          if (Number.isNaN(n) || n < 16) n = 16;
          if (n > 200) n = 200;
          widget.props.size = n;
          renderCanvas();
          scheduleSnippetUpdate();
        });
        
        addSelect("Color", widget.props.color || "black", ["black", "white", "gray"], (val) => {
          widget.props.color = val;
          renderCanvas();
          scheduleSnippetUpdate();
        });
      }

      if (["text", "sensor_text"].includes(type)) {
        if (type === "text") {
          addLabeledInput("Text", "text", widget.props.text || "", (v) => {
            widget.props.text = v;
            renderCanvas();
            scheduleSnippetUpdate();
          });
        }
        if (type === "sensor_text") {
          const entityWrap = document.createElement("div");
          entityWrap.className = "field";
          const entityLbl = document.createElement("div");
          entityLbl.className = "prop-label";
          entityLbl.textContent = "Entity ID";
          
          const entityRow = document.createElement("div");
          entityRow.style.display = "flex";
          entityRow.style.gap = "4px";
          
          const entityInput = document.createElement("input");
          entityInput.className = "prop-input";
          entityInput.type = "text";
          entityInput.value = widget.entity_id || "";
          entityInput.style.flex = "1";
          entityInput.addEventListener("input", () => {
            widget.entity_id = entityInput.value;
            if (hasHaBackend() && Object.keys(entityStatesCache).length === 0) {
              fetchEntityStates();
            }
            renderCanvas();
            scheduleSnippetUpdate();
          });
          
          const pickerBtn = document.createElement("button");
          pickerBtn.className = "btn btn-secondary";
          pickerBtn.textContent = "⋮⋮⋮";
          pickerBtn.style.padding = "5px 8px";
          pickerBtn.style.fontSize = "10px";
          pickerBtn.type = "button";
          pickerBtn.title = "Pick from Home Assistant entities";
          pickerBtn.addEventListener("click", () => {
            openEntityPickerForWidget(widget, entityInput);
          });
          
          entityRow.appendChild(entityInput);
          entityRow.appendChild(pickerBtn);
          entityWrap.appendChild(entityLbl);
          entityWrap.appendChild(entityRow);
          panel.appendChild(entityWrap);
          
          addLabeledInput("Label (leave empty for value only)", "text", widget.title || "", (v) => {
            widget.title = v;
            renderCanvas();
            scheduleSnippetUpdate();
          });
          
          addSelect(
            "Display format",
            widget.props.value_format || "value_only",
            ["value_only", "label_value", "label_newline_value"],
            (val) => {
              widget.props.value_format = val;
              renderCanvas();
              scheduleSnippetUpdate();
            }
          );
          
          addLabeledInput("Label font size", "number", widget.props.label_font_size || 14, (v) => {
            widget.props.label_font_size = parseInt(v || "14", 10) || 14;
            renderCanvas();
            scheduleSnippetUpdate();
          });
          
          addLabeledInput("Value font size", "number", widget.props.value_font_size || 20, (v) => {
            widget.props.value_font_size = parseInt(v || "20", 10) || 20;
            renderCanvas();
            scheduleSnippetUpdate();
          });
        }
        
        if (type === "text") {
          addSelect("Font family", widget.props.font_family || "Inter", ["Inter", "Roboto", "Open Sans", "Lato", "Montserrat", "Poppins"], (val) => {
            widget.props.font_family = val;
            renderCanvas();
            scheduleSnippetUpdate();
          });
          
          addLabeledInput("Font size", "number", widget.props.font_size || 16, (v) => {
            widget.props.font_size = parseInt(v || "16", 10) || 16;
            renderCanvas();
            scheduleSnippetUpdate();
          });
        }
        
        if (type === "sensor_text") {
          addSelect("Font family", widget.props.font_family || "Inter", ["Inter", "Roboto", "Open Sans", "Lato", "Montserrat", "Poppins"], (val) => {
            widget.props.font_family = val;
            renderCanvas();
            scheduleSnippetUpdate();
          });
        }
        
        addSelect("Text color", widget.props.color || "black", ["black", "white", "gray"], (val) => {
          widget.props.color = val;
          renderCanvas();
          scheduleSnippetUpdate();
        });
      }

      if (type === "shape_rect" || type === "shape_circle") {
        const fillWrap = document.createElement("div");
        fillWrap.className = "field";
        const fillLbl = document.createElement("div");
        fillLbl.className = "prop-label";
        fillLbl.textContent = "Fill shape";
        const fillCb = document.createElement("input");
        fillCb.type = "checkbox";
        fillCb.checked = !!widget.props.fill;
        fillCb.addEventListener("change", () => {
          widget.props.fill = fillCb.checked;
          renderCanvas();
          scheduleSnippetUpdate();
        });
        fillWrap.appendChild(fillLbl);
        fillWrap.appendChild(fillCb);
        panel.appendChild(fillWrap);

        addLabeledInput(
          "Border width (px)",
          "number",
          widget.props.border_width != null ? widget.props.border_width : 1,
          (v) => {
            let n = parseInt(v || "1", 10);
            if (Number.isNaN(n) || n < 0) n = 0;
            widget.props.border_width = n;
            renderCanvas();
          }
        );

        addSelect(
          "Shape color",
          widget.props.color || "black",
          ["black", "white", "gray"],
          (val) => {
            widget.props.color = val;
            renderCanvas();
          }
        );

        addLabeledInput(
          "Fill opacity (0-100)",
          "number",
          widget.props.opacity != null ? widget.props.opacity : 100,
          (v) => {
            let n = parseInt(v || "100", 10);
            if (Number.isNaN(n)) n = 100;
            widget.props.opacity = Math.max(0, Math.min(100, n));
            renderCanvas();
          }
        );
      }

      if (type === "line") {
        addLabeledInput(
          "Stroke width (px)",
          "number",
          widget.props.stroke_width != null ? widget.props.stroke_width : 1,
          (v) => {
            let n = parseInt(v || "1", 10);
            if (Number.isNaN(n) || n < 1) n = 1;
            widget.props.stroke_width = n;
            renderCanvas();
          }
        );
        addSelect(
          "Line color",
          widget.props.color || "black",
          ["black", "white", "gray"],
          (val) => {
            widget.props.color = val;
            renderCanvas();
          }
        );
      }

      const condSectionHeader = document.createElement("h3");
      condSectionHeader.textContent = "Conditional Visibility";
      condSectionHeader.style.marginTop = "12px";
      condSectionHeader.style.borderTop = "1px solid var(--border-subtle)";
      condSectionHeader.style.paddingTop = "8px";
      panel.appendChild(condSectionHeader);
      
      const condHelpWrap = document.createElement("div");
      condHelpWrap.className = "field";
      condHelpWrap.style.fontSize = "9px";
      condHelpWrap.style.color = "var(--muted)";
      condHelpWrap.style.marginBottom = "6px";
      condHelpWrap.innerHTML = "Show/hide this widget based on an entity's state.";
      panel.appendChild(condHelpWrap);
      
      const condEntityWrap = document.createElement("div");
      condEntityWrap.className = "field";
      const condEntityLbl = document.createElement("div");
      condEntityLbl.className = "prop-label";
      condEntityLbl.textContent = "Condition Entity (optional)";
      
      const condEntityRow = document.createElement("div");
      condEntityRow.style.display = "flex";
      condEntityRow.style.gap = "4px";
      
      const condEntityInput = document.createElement("input");
      condEntityInput.className = "prop-input";
      condEntityInput.type = "text";
      condEntityInput.value = widget.condition_entity || "";
      condEntityInput.style.flex = "1";
      condEntityInput.placeholder = "e.g., binary_sensor.printer_printing";
      condEntityInput.addEventListener("input", () => {
        widget.condition_entity = condEntityInput.value || null;
        scheduleSnippetUpdate();
      });
      
      const condPickerBtn = document.createElement("button");
      condPickerBtn.className = "btn btn-secondary";
      condPickerBtn.textContent = "⋮⋮⋮";
      condPickerBtn.style.padding = "5px 8px";
      condPickerBtn.style.fontSize = "10px";
      condPickerBtn.type = "button";
      condPickerBtn.title = "Pick from Home Assistant entities";
      condPickerBtn.addEventListener("click", () => {
        openEntityPickerForWidget({
          entity_id: widget.condition_entity || "",
          title: ""
        }, condEntityInput, (selectedEntity) => {
          widget.condition_entity = selectedEntity;
          condEntityInput.value = selectedEntity;
          scheduleSnippetUpdate();
        });
      });
      
      condEntityRow.appendChild(condEntityInput);
      condEntityRow.appendChild(condPickerBtn);
      condEntityWrap.appendChild(condEntityLbl);
      condEntityWrap.appendChild(condEntityRow);
      panel.appendChild(condEntityWrap);
      
      addSelect(
        "Operator",
        widget.condition_operator || "==",
        ["==", "!=", ">", "<", ">=", "<="],
        (val) => {
          widget.condition_operator = val;
          scheduleSnippetUpdate();
        }
      );
      
      addLabeledInput("Expected value", "text", widget.condition_state || "", (v) => {
        widget.condition_state = v || null;
        scheduleSnippetUpdate();
      });
      
      const clearCondWrap = document.createElement("div");
      clearCondWrap.className = "field";
      clearCondWrap.style.marginTop = "4px";
      const clearCondBtn = document.createElement("button");
      clearCondBtn.className = "btn btn-secondary btn-full";
      clearCondBtn.textContent = "Clear Condition";
      clearCondBtn.type = "button";
      clearCondBtn.addEventListener("click", () => {
        widget.condition_entity = null;
        widget.condition_state = null;
        widget.condition_operator = null;
        renderPropertiesPanel();
        scheduleSnippetUpdate();
      });
      clearCondWrap.appendChild(clearCondBtn);
      panel.appendChild(clearCondWrap);
    }

    function screenToCanvasPosition(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      let x = clientX - rect.left;
      let y = clientY - rect.top;
      x = Math.max(0, Math.min(CANVAS_WIDTH - 10, x));
      y = Math.max(0, Math.min(CANVAS_HEIGHT - 10, y));
      return { x, y };
    }

    let dragState = null;

    function onWidgetMouseDown(ev, widgetId) {
      const widget = widgetsById.get(widgetId);
      if (!widget) return;
      selectedWidgetId = widgetId;
      renderCanvas();
      renderPropertiesPanel();

      const target = ev.target;
      const rect = canvas.getBoundingClientRect();

      if (target.classList.contains("widget-resize-handle")) {
        dragState = {
          mode: "resize",
          id: widgetId,
          startX: ev.clientX,
          startY: ev.clientY,
          startW: widget.width,
          startH: widget.height
        };
      } else {
        dragState = {
          mode: "move",
          id: widgetId,
          offsetX: ev.clientX - (rect.left + widget.x),
          offsetY: ev.clientY - (rect.top + widget.y)
        };
      }

      window.addEventListener("mousemove", onMouseMove);
      window.addEventListener("mouseup", onMouseUp);
      ev.preventDefault();
    }

    function deleteWidget(widgetId) {
      const page = getCurrentPage();
      if (!page) return;
      const idx = page.widgets.findIndex((w) => w.id === widgetId);
      if (idx === -1) return;
      page.widgets.splice(idx, 1);
      widgetsById.delete(widgetId);
      selectedWidgetId = null;
      renderCanvas();
      renderPropertiesPanel();
      scheduleSnippetUpdate();
    }

    function deletePage(pageIndex) {
      if (pages.length <= 1) {
        alert("Cannot delete the last page. At least one page is required.");
        return;
      }
      
      pages.splice(pageIndex, 1);
      
      if (currentPageIndex >= pages.length) {
        currentPageIndex = pages.length - 1;
      } else if (currentPageIndex > pageIndex) {
        currentPageIndex--;
      }
      
      selectedWidgetId = null;
      rebuildWidgetsIndex();
      renderPagesSidebar();
      renderCanvas();
      renderPropertiesPanel();
      scheduleSnippetUpdate();
    }

    window.addEventListener("keydown", (ev) => {
      if ((ev.key === "Delete" || ev.key === "Backspace") && selectedWidgetId) {
        if (ev.target.tagName === "INPUT" || ev.target.tagName === "TEXTAREA") {
          return;
        }
        ev.preventDefault();
        deleteWidget(selectedWidgetId);
      }
    });

    function onMouseMove(ev) {
      if (!dragState) return;
      const widget = widgetsById.get(dragState.id);
      if (!widget) return;

      if (!canvas.querySelector(".canvas-grid")) {
        const grid = document.createElement("div");
        grid.className = "canvas-grid";
        canvas.insertBefore(grid, canvas.firstChild || null);
      }

      if (dragState.mode === "move") {
        const rect = canvas.getBoundingClientRect();
        let x = ev.clientX - rect.left - dragState.offsetX;
        let y = ev.clientY - rect.top - dragState.offsetY;
        x = Math.max(0, Math.min(CANVAS_WIDTH - widget.width, x));
        y = Math.max(0, Math.min(CANVAS_HEIGHT - widget.height, y));

        const snapped = applySnapToPosition(widget, x, y, ev);
        widget.x = snapped.x;
        widget.y = snapped.y;
      } else if (dragState.mode === "resize") {
        let w = dragState.startW + (ev.clientX - dragState.startX);
        let h = dragState.startH + (ev.clientY - dragState.startY);
        w = Math.max(10, Math.min(CANVAS_WIDTH - widget.x, w));
        h = Math.max(10, Math.min(CANVAS_HEIGHT - widget.y, h));
        widget.width = Math.round(w);
        widget.height = Math.round(h);
        
        const wtype = (widget.type || "").toLowerCase();
        if (wtype === "icon") {
          const props = widget.props || {};
          if (props.fit_icon_to_frame) {
            const padding = 4;
            const maxDim = Math.max(8, Math.min(widget.width - padding * 2, widget.height - padding * 2));
            props.size = Math.round(maxDim);
          } else {
            const newSize = Math.max(8, Math.min(widget.width, widget.height));
            props.size = Math.round(newSize);
          }
        }
      }

      renderCanvas();
    }

    function onMouseUp() {
      dragState = null;
      clearSnapGuides();
      window.removeEventListener("mousemove", onMouseMove);
      window.removeEventListener("mouseup", onMouseUp);
      renderCanvas();
      renderPropertiesPanel();
      scheduleSnippetUpdate();
    }

    function getPagesPayload() {
      return {
        device_id: "reterminal_e1001",
        name: "reTerminal E1001",
        current_page: currentPageIndex,
        pages
      };
    }

    function generateSnippetLocally() {
      const payload = getPagesPayload();
      const pagesLocal = payload.pages || [];
      const lines = [];

      const iconCodes = new Set();
      for (const page of pagesLocal) {
        if (!page || !Array.isArray(page.widgets)) continue;
        for (const w of page.widgets) {
          const t = (w.type || "").toLowerCase();
          const p = w.props || {};
          if (t === "icon") {
            const raw = (p.code || "").trim().toUpperCase().replace(/^0X/, "");
            if (/^F[0-9A-F]{4}$/i.test(raw)) {
              iconCodes.add(raw);
            }
          }
        }
      }

      lines.push("# Local preview snippet (fallback)");
      lines.push("# Paste below your base ESPHome config.");
      lines.push("# IMPORTANT: Ensure 'materialdesignicons-webfont.ttf' is placed in your ESPHome config:");
      lines.push("#   /config/esphome/fonts/materialdesignicons-webfont.ttf");
      lines.push("# Then keep the 'file: fonts/materialdesignicons-webfont.ttf' path below.");
      lines.push("");

      if (iconCodes.size > 0) {
        lines.push("font:");
        lines.push("  # Icon fonts used by MDI icon widgets generated from the reTerminal editor.");
        lines.push("  - file: 'fonts/materialdesignicons-webfont.ttf'");
        lines.push("    id: font_mdi_large");
        lines.push("    size: 200");
        lines.push("    glyphs: &mdi_glyphs");
        iconCodes.forEach((code) => {
          const hex = code.toUpperCase();
          lines.push(`      - "\\\\U000${hex}"`);
        });
        lines.push("  - file: 'fonts/materialdesignicons-webfont.ttf'");
        lines.push("    id: font_mdi_medium");
        lines.push("    size: 40");
        lines.push("    glyphs: *mdi_glyphs");
        lines.push("");
      }

      lines.push("globals:");
      lines.push("  - id: display_page");
      lines.push("    type: int");
      lines.push("    restore_value: true");
      lines.push("    initial_value: '0'");
      lines.push("");
      lines.push("display:");
      lines.push("  - platform: waveshare_epaper");
      lines.push("    id: epaper_display");
      lines.push("    model: 7.50in-bV3");
      lines.push("    update_interval: 0s");
      lines.push("    lambda: |-");
      lines.push("      int page = id(display_page);");

      pagesLocal.forEach((page, pageIndex) => {
        lines.push(`      if (page == ${pageIndex}) {`);
        if (!page.widgets || !page.widgets.length) {
          lines.push("        // No widgets on this page.");
        } else {
          for (const w of page.widgets) {
            const t = (w.type || "").toLowerCase();
            const p = w.props || {};
            if (t === "text" || t === "label") {
              const txt = (p.text || w.title || "Text").replace(/"/g, '\\"');
              if (!txt) continue;
              const fontSize = parseInt(p.font_size || 12, 10) || 12;
              const colorProp = p.color || "black";
              const color = colorProp === "white" ? "COLOR_ON" : "COLOR_OFF";
              lines.push(`        // widget:text id:${w.id} type:text x:${w.x} y:${w.y} w:${w.width} h:${w.height} text:"${txt}" font_size:${fontSize} color:${colorProp}`);
              lines.push(`        it.print(${w.x}, ${w.y}, id(font_normal), ${color}, "${txt}");`);
            } else if (t === "sensor_text") {
              const entityId = (w.entity_id || "").trim();
              const label = (w.title || "").replace(/"/g, '\\"');
              const valueFormat = p.value_format || "label_value";
              const labelFontSize = parseInt(p.label_font_size || 14, 10) || 14;
              const valueFontSize = parseInt(p.value_font_size || 20, 10) || 20;
              const color = p.color === "white" ? "COLOR_ON" : "COLOR_OFF";
              
              if (entityId) {
                const safeId = entityId.replace(/\./g, "_").replace(/-/g, "_");
                lines.push(`        // widget:sensor_text id:${w.id} type:sensor_text x:${w.x} y:${w.y} w:${w.width} h:${w.height} ent:${entityId} title:"${label}" label_font:${labelFontSize} value_font:${valueFontSize} format:${valueFormat}`);
                if (valueFormat === "label_newline_value" && label) {
                  lines.push(`        it.printf(${w.x}, ${w.y}, id(font_normal), ${color}, "${label}");`);
                  const valueY = w.y + labelFontSize + 4;
                  lines.push(`        it.printf(${w.x}, ${valueY}, id(font_normal), ${color}, "%s", id(${safeId}).state.c_str());`);
                } else if (valueFormat === "label_value" && label) {
                  lines.push(`        it.printf(${w.x}, ${w.y}, id(font_normal), ${color}, "${label}: %s", id(${safeId}).state.c_str());`);
                } else {
                  lines.push(`        it.printf(${w.x}, ${w.y}, id(font_normal), ${color}, "%s", id(${safeId}).state.c_str());`);
                }
              } else {
                const placeholder = label || "sensor";
                lines.push(`        // widget:sensor_text id:${w.id} type:sensor_text x:${w.x} y:${w.y} w:${w.width} h:${w.height} title:"${label}" label_font:${labelFontSize} value_font:${valueFontSize}`);
                lines.push(`        // No entity_id configured for this sensor_text widget`);
                lines.push(`        it.printf(${w.x}, ${w.y}, id(font_normal), ${color}, "${placeholder}: N/A");`);
              }
            } else if (t === "icon") {
              const raw = (p.code || "").trim().toUpperCase().replace(/^0X/, "");
              if (!/^F[0-9A-F]{4}$/i.test(raw)) continue;
              const hex = raw.toUpperCase();
              const size = parseInt(p.size || 48, 10) || 48;
              const glyphEsc = `\\\\U000${hex}`;
              const fontRef = p.font_ref === "font_mdi_large" ? "font_mdi_large" : "font_mdi_medium";
              const color = p.color === "white" ? "COLOR_ON" : "COLOR_OFF";
              lines.push(`        // widget:icon id:${w.id} type:icon x:${w.x} y:${w.y} w:${w.width} h:${w.height} code:${hex} size:${size} color:${p.color || "black"}`);
              lines.push(
                `        it.printf(${w.x}, ${w.y}, id(${fontRef}), ${color}, "${glyphEsc}");`
              );
            } else if (t === "datetime") {
              const format = p.format || "time_date";
              const timeFontSize = parseInt(p.time_font_size || 28, 10) || 28;
              const dateFontSize = parseInt(p.date_font_size || 16, 10) || 16;
              const color = p.color === "white" ? "COLOR_ON" : "COLOR_OFF";
              lines.push(`        // widget:datetime id:${w.id} type:datetime x:${w.x} y:${w.y} w:${w.width} h:${w.height} format:${format} time_font:${timeFontSize} date_font:${dateFontSize}`);
              if (format === "time_only") {
                lines.push(`        it.strftime(${w.x}, ${w.y}, id(font_normal), ${color}, "%H:%M", id(ha_time).now());`);
              } else if (format === "date_only") {
                lines.push(`        it.strftime(${w.x}, ${w.y}, id(font_normal), ${color}, "%a, %b %d", id(ha_time).now());`);
              } else {
                lines.push(`        it.strftime(${w.x}, ${w.y}, id(font_normal), ${color}, "%H:%M", id(ha_time).now());`);
                const dateY = w.y + timeFontSize + 4;
                lines.push(`        it.strftime(${w.x}, ${dateY}, id(font_normal), ${color}, "%a, %b %d", id(ha_time).now());`);
              }
            } else if (t === "progress_bar") {
              const entityId = (w.entity_id || "").trim();
              const label = (w.title || "").replace(/"/g, '\\"');
              const barHeight = parseInt(p.bar_height || 15, 10) || 15;
              const borderWidth = parseInt(p.border_width || 1, 10) || 1;
              const color = p.color === "white" ? "COLOR_ON" : "COLOR_OFF";
              if (entityId) {
                const safeId = entityId.replace(/\./g, "_").replace(/-/g, "_");
                lines.push(`        // widget:progress_bar id:${w.id} type:progress_bar x:${w.x} y:${w.y} w:${w.width} h:${w.height} entity:${entityId}`);
                lines.push(`        it.rectangle(${w.x}, ${w.y}, ${w.width}, ${barHeight}, ${color});`);
                lines.push(`        // Fill progress bar based on sensor value`);
                lines.push(`        { float progress = id(${safeId}).state; if (progress > 0 && progress <= 100) {`);
                lines.push(`          int fill_w = (int)((${w.width} - 2) * (progress / 100.0));`);
                lines.push(`          it.filled_rectangle(${w.x}+1, ${w.y}+1, fill_w, ${barHeight}-2, ${color}); }}`);
              } else {
                lines.push(`        // widget:progress_bar id:${w.id} type:progress_bar x:${w.x} y:${w.y} w:${w.width} h:${w.height} (no entity)`);
                lines.push(`        it.rectangle(${w.x}, ${w.y}, ${w.width}, ${barHeight}, ${color});`);
              }
            } else if (t === "battery_icon") {
              const entityId = (w.entity_id || "").trim();
              const size = parseInt(p.size || 48, 10) || 48;
              const color = p.color === "white" ? "COLOR_ON" : "COLOR_OFF";
              const fontRef = "font_mdi_medium";
              if (entityId) {
                const safeId = entityId.replace(/\./g, "_").replace(/-/g, "_");
                lines.push(`        // widget:battery_icon id:${w.id} type:battery_icon x:${w.x} y:${w.y} w:${w.width} h:${w.height} entity:${entityId} size:${size}`);
                lines.push(`        { float level = id(${safeId}).state;`);
                lines.push(`          const char* icon = level <= 10 ? "\\\\U000F007A" : level <= 50 ? "\\\\U000F007E" : "\\\\U000F0079";`);
                lines.push(`          it.printf(${w.x}, ${w.y}, id(${fontRef}), ${color}, "%s", icon);`);
                lines.push(`          it.printf(${w.x}, ${w.y}+${size}+2, id(font_small), ${color}, "%.0f%%", level); }`);
              } else {
                lines.push(`        // widget:battery_icon id:${w.id} type:battery_icon x:${w.x} y:${w.y} w:${w.width} h:${w.height} size:${size} (no entity)`);
                lines.push(`        it.printf(${w.x}, ${w.y}, id(${fontRef}), ${color}, "\\\\U000F0079");  // battery`);
              }
            } else if (t === "image") {
              const path = (p.path || "").trim();
              const invert = !!p.invert;
              const color = p.color === "white" ? "COLOR_ON" : "COLOR_OFF";
              if (path) {
                const safeId = "img_" + path.replace(/[^a-zA-Z0-9]/g, "_");
                lines.push(`        // widget:image id:${w.id} type:image x:${w.x} y:${w.y} w:${w.width} h:${w.height} path:"${path}" invert:${invert}`);
                if (invert) {
                  lines.push(`        it.image(${w.x}, ${w.y}, id(${safeId}), COLOR_OFF, COLOR_ON);`);
                } else {
                  lines.push(`        it.image(${w.x}, ${w.y}, id(${safeId}));`);
                }
              } else {
                lines.push(`        // widget:image id:${w.id} type:image x:${w.x} y:${w.y} w:${w.width} h:${w.height} (no path)`);
                lines.push(`        it.rectangle(${w.x}, ${w.y}, ${w.width}, ${w.height}, ${color});`);
              }
            } else if (t === "online_image") {
              const url = (p.url || "").trim();
              const color = p.color === "white" ? "COLOR_ON" : "COLOR_OFF";
              const safeId = `img_${w.id}`.replace(/-/g, "_");
              lines.push(`        // widget:online_image id:${w.id} type:online_image x:${w.x} y:${w.y} w:${w.width} h:${w.height} url:"${url}"`);
              if (url) {
                lines.push(`        it.image(${w.x}, ${w.y}, id(${safeId}));`);
              } else {
                lines.push(`        // No URL configured`);
                lines.push(`        it.rectangle(${w.x}, ${w.y}, ${w.width}, ${w.height}, ${color});`);
              }
            } else if (t === "shape_rect") {
              const colorProp = p.color || "black";
              const color = colorProp === "white" ? "COLOR_ON" : "COLOR_OFF";
              const fill = !!p.fill;
              const borderWidth = parseInt(p.border_width || 1, 10) || 1;
              lines.push(`        // widget:shape_rect id:${w.id} type:shape_rect x:${w.x} y:${w.y} w:${w.width} h:${w.height} fill:${fill} border:${borderWidth} color:${colorProp}`);
              if (fill) {
                if (colorProp === "grey" || colorProp === "gray") {
                  lines.push(`        // Grey fill using 50% checkerboard dithering pattern`);
                  lines.push(`        for (int dy = 0; dy < ${w.height}; dy++) {`);
                  lines.push(`          for (int dx = 0; dx < ${w.width}; dx++) {`);
                  lines.push(`            if ((dx + dy) % 2 == 0) {`);
                  lines.push(`              it.draw_pixel_at(${w.x}+dx, ${w.y}+dy, COLOR_OFF);`);
                  lines.push(`            }`);
                  lines.push(`          }`);
                  lines.push(`        }`);
                } else {
                  lines.push(`        it.filled_rectangle(${w.x}, ${w.y}, ${w.width}, ${w.height}, ${color});`);
                }
                if (borderWidth > 1) {
                  lines.push(`        it.rectangle(${w.x}, ${w.y}, ${w.width}, ${w.height}, ${color});`);
                }
              } else {
                if (borderWidth <= 1) {
                  lines.push(`        it.rectangle(${w.x}, ${w.y}, ${w.width}, ${w.height}, ${color});`);
                } else {
                  lines.push(`        // rectangle with border_width=${borderWidth}`);
                  lines.push(`        for (int i = 0; i < ${borderWidth}; i++) {`);
                  lines.push(
                    `          it.rectangle(${w.x}+i, ${w.y}+i, ${w.width}-2*i, ${w.height}-2*i, ${color});`
                  );
                  lines.push("        }");
                }
              }
            } else if (t === "shape_circle") {
              const colorProp = p.color || "black";
              const color = colorProp === "white" ? "COLOR_ON" : "COLOR_OFF";
              const wSafe = Math.max(1, w.width || 1);
              const hSafe = Math.max(1, w.height || 1);
              const r = Math.max(1, Math.floor(Math.min(wSafe, hSafe) / 2));
              const cx = w.x + Math.floor(wSafe / 2);
              const cy = w.y + Math.floor(hSafe / 2);
              const fill = !!p.fill;
              const borderWidth = parseInt(p.border_width || 1, 10) || 1;
              lines.push(`        // widget:shape_circle id:${w.id} type:shape_circle x:${w.x} y:${w.y} w:${w.width} h:${w.height} fill:${fill} border:${borderWidth} color:${colorProp}`);
              if (fill) {
                if (colorProp === "grey" || colorProp === "gray") {
                  lines.push(`        // Grey fill using 50% checkerboard dithering pattern within circle`);
                  lines.push(`        for (int dy = -${r}; dy <= ${r}; dy++) {`);
                  lines.push(`          for (int dx = -${r}; dx <= ${r}; dx++) {`);
                  lines.push(`            if (dx*dx + dy*dy <= ${r}*${r}) {`);
                  lines.push(`              if ((dx + dy) % 2 == 0) {`);
                  lines.push(`                it.draw_pixel_at(${cx}+dx, ${cy}+dy, COLOR_OFF);`);
                  lines.push(`              }`);
                  lines.push(`            }`);
                  lines.push(`          }`);
                  lines.push(`        }`);
                } else {
                  lines.push(`        it.filled_circle(${cx}, ${cy}, ${r}, ${color});`);
                }
                if (borderWidth > 1) {
                  lines.push(`        it.circle(${cx}, ${cy}, ${r}, ${color});`);
                }
              } else {
                if (borderWidth <= 1) {
                  lines.push(`        it.circle(${cx}, ${cy}, ${r}, ${color});`);
                } else {
                  lines.push(`        // circle with border_width=${borderWidth}`);
                  lines.push(`        for (int i = 0; i < ${borderWidth}; i++) {`);
                  lines.push(`          it.circle(${cx}, ${cy}, ${r}-i, ${color});`);
                  lines.push("        }");
                }
              }
            } else if (t === "line") {
              const colorProp = p.color || "black";
              const color = colorProp === "white" ? "COLOR_ON" : "COLOR_OFF";
              const dx = w.width || 0;
              const dy = w.height || 0;
              const x2 = w.x + dx;
              const y2 = w.y + dy;
              const strokeWidth = parseInt(p.stroke_width || 1, 10) || 1;
              lines.push(`        // widget:line id:${w.id} type:line x:${w.x} y:${w.y} w:${w.width} h:${w.height} stroke:${strokeWidth} color:${colorProp}`);
              if (strokeWidth <= 1) {
                lines.push(`        it.line(${w.x}, ${w.y}, ${x2}, ${y2}, ${color});`);
              } else {
                lines.push(`        // line with stroke_width=${strokeWidth}`);
                lines.push("        for (int i = 0; i < " + strokeWidth + "; i++) {");
                lines.push(`          it.line(${w.x}, ${w.y}+i, ${x2}, ${y2}+i, ${color});`);
                lines.push("        }");
              }
            }
          }
        }
        lines.push("      }");
      });

      return lines.join("\n");
    }

    async function updateSnippet(preferBackend = true) {
      if (!snippetBox) return;

      const local = generateSnippetLocally();

      if (!preferBackend) {
        snippetBox.value = local + "\n# Local preview (no backend).";
        return;
      }

      try {
        // First, save the current layout to backend so it knows about the changes
        const body = getPagesPayload();
        const saveResp = await fetch("/api/reterminal_dashboard/layout", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body)
        });
        
        if (!saveResp.ok) {
          throw new Error("Failed to save layout to backend");
        }

        // Now fetch the generated snippet from backend
        const resp = await fetch("/api/reterminal_dashboard/snippet", { method: "GET" });
        if (!resp.ok) {
          throw new Error("HTTP " + resp.status);
        }
        const text = await resp.text();
        snippetBox.value = (text && text.trim()) ? text : "# Empty snippet";
      } catch (err) {
        console.warn("Backend error, using local generation:", err);
        snippetBox.value =
          local + "\n# Backend unreachable, showing local preview only.";
      }
    }

    let snippetDebounceTimer = null;
    function scheduleSnippetUpdate() {
      if (!snippetBox) return;
      if (snippetDebounceTimer) clearTimeout(snippetDebounceTimer);
      snippetDebounceTimer = setTimeout(() => {
        updateSnippet(true);
      }, 300);
    }

    document.getElementById("widgetPalette").addEventListener("click", onWidgetPaletteClick);

    const snapToggleEl = document.getElementById("snapToggle");
    if (snapToggleEl) {
      snapToggleEl.checked = snapEnabled;
      snapToggleEl.addEventListener("change", () => {
        snapEnabled = !!snapToggleEl.checked;
        clearSnapGuides();
      });
    }

    let haEntitiesCache = null;
    let haEntitiesLoaded = false;
    let haEntitiesLoadError = false;

    async function loadHaEntitiesIfNeeded() {
      if (!hasHaBackend || !hasHaBackend()) {
        haEntitiesLoadError = true;
        return [];
      }
      if (haEntitiesLoaded && haEntitiesCache) {
        return haEntitiesCache;
      }
      try {
        const resp = await fetch(`${HA_API_BASE}/entities?domains=sensor,binary_sensor,weather`);
        if (!resp.ok) {
          throw new Error("HTTP " + resp.status);
        }
        const data = await resp.json();
        if (!Array.isArray(data)) {
          throw new Error("Invalid response format");
        }
        haEntitiesCache = data;
        haEntitiesLoaded = true;
        return haEntitiesCache;
      } catch (err) {
        console.warn("Failed to load entities for picker; falling back to manual input.", err);
        haEntitiesLoadError = true;
        return [];
      }
    }

    function openEntityPickerForWidget(widget, inputEl, callback) {
      if (!hasHaBackend || !hasHaBackend() || haEntitiesLoadError) {
        return;
      }

      const container = propertiesPanel;
      const existing = container.querySelector(".entity-picker-overlay");
      if (existing) {
        existing.remove();
      }

      const overlay = document.createElement("div");
      overlay.className = "entity-picker-overlay";
      overlay.style.marginTop = "4px";
      overlay.style.padding = "4px";
      overlay.style.borderRadius = "6px";
      overlay.style.border = "1px solid var(--border-subtle)";
      overlay.style.background = "#05070b";
      overlay.style.display = "flex";
      overlay.style.flexDirection = "column";
      overlay.style.gap = "4px";
      overlay.style.maxHeight = "160px";
      overlay.style.overflow = "hidden";

      const header = document.createElement("div");
      header.style.display = "flex";
      header.style.justifyContent = "space-between";
      header.style.alignItems = "center";
      header.style.gap = "4px";
      header.style.fontSize = "8px";
      header.style.color = "var(--muted)";
      header.textContent = "Pick Home Assistant entity";

      const closeBtn = document.createElement("button");
      closeBtn.className = "btn btn-secondary";
      closeBtn.textContent = "×";
      closeBtn.style.padding = "0 4px";
      closeBtn.style.fontSize = "9px";
      closeBtn.type = "button";
      closeBtn.addEventListener("click", () => {
        overlay.remove();
      });

      const headerRight = document.createElement("div");
      headerRight.style.display = "flex";
      headerRight.style.alignItems = "center";
      headerRight.style.gap = "4px";
      headerRight.appendChild(closeBtn);

      const headerWrap = document.createElement("div");
      headerWrap.style.display = "flex";
      headerWrap.style.justifyContent = "space-between";
      headerWrap.style.alignItems = "center";
      headerWrap.style.gap = "4px";
      headerWrap.appendChild(header);
      headerWrap.appendChild(headerRight);

      const searchRow = document.createElement("div");
      searchRow.style.display = "flex";
      searchRow.style.gap = "4px";
      searchRow.style.alignItems = "center";

      const searchInput = document.createElement("input");
      searchInput.type = "text";
      searchInput.className = "prop-input";
      searchInput.placeholder = "Search name or entity_id";
      searchInput.style.flex = "1";

      const domainSelect = document.createElement("select");
      domainSelect.className = "prop-input";
      domainSelect.style.width = "80px";
      ["all", "sensor", "binary_sensor", "weather"].forEach((d) => {
        const opt = document.createElement("option");
        opt.value = d;
        opt.textContent = d;
        domainSelect.appendChild(opt);
      });

      searchRow.appendChild(searchInput);
      searchRow.appendChild(domainSelect);

      const list = document.createElement("div");
      list.style.flex = "1";
      list.style.overflowY = "auto";
      list.style.borderRadius = "4px";
      list.style.border = "1px solid var(--border-subtle)";
      list.style.padding = "2px";
      list.style.fontSize = "8px";

      overlay.appendChild(headerWrap);
      overlay.appendChild(searchRow);
      overlay.appendChild(list);
      container.appendChild(overlay);

      function renderList(entities) {
        list.innerHTML = "";
        if (!entities || entities.length === 0) {
          const empty = document.createElement("div");
          empty.style.color = "var(--muted)";
          empty.textContent = "No entities match.";
          list.appendChild(empty);
          return;
        }
        entities.forEach((e) => {
          const row = document.createElement("div");
          row.style.display = "flex";
          row.style.flexDirection = "column";
          row.style.padding = "2px 3px";
          row.style.borderRadius = "3px";
          row.style.cursor = "pointer";

          row.addEventListener("mouseenter", () => {
            row.style.background = "#0d1118";
          });
          row.addEventListener("mouseleave", () => {
            row.style.background = "transparent";
          });

          const name = document.createElement("div");
          name.style.fontSize = "8px";
          name.style.color = "var(--text)";
          name.textContent = e.name || e.entity_id;

          const meta = document.createElement("div");
          meta.style.fontSize = "7px";
          meta.style.color = "var(--muted)";
          meta.textContent = `${e.entity_id} · ${e.domain}`;

          row.appendChild(name);
          row.appendChild(meta);

          row.addEventListener("click", () => {
            if (callback) {
              callback(e.entity_id);
            } else {
              widget.entity_id = e.entity_id;
              widget.title = e.name || e.entity_id || "";
              inputEl.value = widget.entity_id;
              if (Object.keys(entityStatesCache).length === 0) {
                fetchEntityStates();
              }
              renderCanvas();
              renderPropertiesPanel();
              scheduleSnippetUpdate();
            }
            overlay.remove();
          });

          list.appendChild(row);
        });
      }

      loadHaEntitiesIfNeeded().then((entities) => {
        if (!entities || entities.length === 0) {
          renderList([]);
          return;
        }

        function applyFilter() {
          const q = (searchInput.value || "").toLowerCase();
          const dom = domainSelect.value;
          const filtered = entities.filter((e) => {
            if (dom !== "all" && e.domain !== dom) {
              return false;
            }
            if (!q) return true;
            const hay = `${e.entity_id} ${e.name || ""}`.toLowerCase();
            return hay.includes(q);
          });
          renderList(filtered);
        }

        searchInput.addEventListener("input", applyFilter);
        domainSelect.addEventListener("change", applyFilter);

        applyFilter();
      });
    }

    const orientationSelectEl = document.getElementById("orientationSelect");
    if (orientationSelectEl) {
      orientationSelectEl.addEventListener("change", () => {
        applyOrientation(orientationSelectEl.value);
        scheduleSnippetUpdate();
      });
    }

    addPageBtn.onclick = () => {
      const id = "page_" + pages.length;
      pages.push({ id, name: "Page " + (pages.length + 1), widgets: [] });
      currentPageIndex = pages.length - 1;
      rebuildWidgetsIndex();
      renderPagesSidebar();
      renderCanvas();
      renderPropertiesPanel();
      scheduleSnippetUpdate();
    };

    const clearAllBtn = document.getElementById("clearAllBtn");
    if (clearAllBtn) {
      clearAllBtn.onclick = () => {
        const page = getCurrentPage();
        if (!page) return;
        
        if (page.widgets.length === 0) {
          sidebarStatus.textContent = "Current page is already empty.";
          return;
        }
        
        if (confirm(`Remove all ${page.widgets.length} widget(s) from "${page.name}"? This cannot be undone.`)) {
          page.widgets = [];
          selectedWidgetId = null;
          rebuildWidgetsIndex();
          renderCanvas();
          renderPropertiesPanel();
          scheduleSnippetUpdate();
          sidebarStatus.textContent = `Cleared all widgets from "${page.name}".`;
        }
      };
    }

    saveLayoutBtn.onclick = async () => {
      const body = getPagesPayload();
      console.log("Saving layout:", body);
      console.log("Pages:", body.pages?.length, "widgets:", body.pages?.reduce((sum, p) => sum + (p.widgets?.length || 0), 0));
      try {
        const resp = await fetch("/api/reterminal_dashboard/layout", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body)
        });
        console.log("Save response status:", resp.status, resp.ok);
        if (!resp.ok) {
          const errText = await resp.text();
          console.error("Save failed:", errText);
          sidebarStatus.textContent = "Failed to save layout via API.";
          return;
        }
        const result = await resp.json();
        console.log("Save successful:", result);
        sidebarStatus.textContent = "Layout saved.";
        scheduleSnippetUpdate();
      } catch (err) {
        console.error("Save error:", err);
        sidebarStatus.textContent = "Failed to save layout (network error).";
      }
    };

    if (generateSnippetBtn) {
      generateSnippetBtn.addEventListener("click", async () => {
        await updateSnippet(true);
      });
    }

    copySnippetBtn.onclick = async () => {
      const text = snippetBox.value || "";
      try {
        if (navigator.clipboard && window.isSecureContext) {
          await navigator.clipboard.writeText(text);
          sidebarStatus.textContent = "Snippet copied to clipboard.";
        } else {
          const textarea = document.createElement("textarea");
          textarea.value = text;
          textarea.style.position = "fixed";
          textarea.style.left = "-999999px";
          document.body.appendChild(textarea);
          textarea.select();
          try {
            document.execCommand("copy");
            sidebarStatus.textContent = "Snippet copied to clipboard.";
          } catch {
            sidebarStatus.textContent = "Unable to copy snippet. Try selecting and copying manually.";
          }
          document.body.removeChild(textarea);
        }
      } catch {
        sidebarStatus.textContent = "Unable to copy snippet.";
      }
    };

    fullscreenSnippetBtn.onclick = () => {
      snippetFullscreenContent.textContent = snippetBox.value || "";
      snippetFullscreenModal.classList.remove("hidden");
    };

    snippetFullscreenClose.onclick = () => {
      snippetFullscreenModal.classList.add("hidden");
    };

    const pageSettingsClose = document.getElementById("pageSettingsClose");
    const pageSettingsSave = document.getElementById("pageSettingsSave");
    if (pageSettingsClose) {
      pageSettingsClose.addEventListener("click", closePageSettingsModal);
    }
    if (pageSettingsSave) {
      pageSettingsSave.addEventListener("click", savePageSettings);
    }

    async function loadLayoutFromBackend() {
      console.log("Loading layout from backend...");
      try {
        const resp = await fetch("/api/reterminal_dashboard/layout");
        console.log("Load response status:", resp.status, resp.ok);
        if (!resp.ok) {
          console.warn("Load failed, initializing default layout");
          initDefaultLayout();
          return;
        }
        const data = await resp.json();
        console.log("Loaded layout:", data);
        console.log("Pages:", data.pages?.length, "widgets:", data.pages?.reduce((sum, p) => sum + (p.widgets?.length || 0), 0));
        pages = data.pages || [];
        currentPageIndex = data.current_page || 0;
        if (!pages.length) {
          console.warn("No pages in loaded layout, initializing default");
          initDefaultLayout();
          return;
        }
        rebuildWidgetsIndex();
        renderPagesSidebar();
        renderCanvas();
        renderPropertiesPanel();
        console.log("Layout loaded successfully");
      } catch (err) {
        console.error("Load error:", err);
        initDefaultLayout();
      }
    }

    loadLayoutFromBackend().then(() => {
      updateSnippet(true);
      loadHaEntitiesIfNeeded().catch(err => {
        console.warn("Entity loading failed during init:", err);
      });
    });
  </script>
</body>
</html>