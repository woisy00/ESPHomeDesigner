<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>reTerminal Dashboard Designer · YAML Snippet Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #0f1115;
      --bg-elevated: #181b22;
      --accent: #52c7ea;
      --accent-soft: rgba(82, 199, 234, 0.16);
      --border-subtle: #2a2f3a;
      --text: #e5e9f0;
      --muted: #7b8190;
      --danger: #ff6b81;
      --font: system-ui, -apple-system, BlinkMacSystemFont, -sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: var(--font);
      background: radial-gradient(circle at top left, #1c1f26 0, #050609 40%, #020308 100%);
      color: var(--text);
      display: flex;
    }

    .sidebar {
      width: 260px;
      background: linear-gradient(to bottom, #151821, #0c0f15);
      border-right: 1px solid var(--border-subtle);
      padding: 16px 14px 12px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      overflow-y: auto;
    }

    .sidebar h1 {
      font-size: 16px;
      margin: 0;
      display: flex;
      align-items: center;
      gap: 8px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .logo-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 12px var(--accent);
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      font-size: 10px;
      color: var(--muted);
      margin-top: 6px;
    }

    .pill span {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 8px var(--accent);
    }

    .sidebar-section-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--muted);
      margin-bottom: 6px;
    }

    select,
    input,
    button,
    textarea {
      font-family: var(--font);
    }

    .select,
    .input {
      width: 100%;
      padding: 7px 9px;
      font-size: 12px;
      border-radius: 6px;
      border: 1px solid var(--border-subtle);
      background: #0f1118;
      color: var(--text);
      outline: none;
    }

    .select:focus,
    .input:focus,
    textarea:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }

    .sidebar-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .btn {
      border: 1px solid var(--accent);
      background: transparent;
      color: var(--accent);
      padding: 6px 9px;
      border-radius: 6px;
      font-size: 11px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      transition: all 0.16s ease;
    }

    .btn:hover {
      background: var(--accent-soft);
      transform: translateY(-1px);
      box-shadow: 0 6px 14px rgba(0, 0, 0, 0.35);
    }

    .btn-secondary {
      border-color: var(--border-subtle);
      color: var(--muted);
    }

    .btn-secondary:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .btn-full {
      width: 100%;
      justify-content: center;
      margin-top: 4px;
    }

    .page-list,
    .widget-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .item {
      padding: 5px 7px;
      border-radius: 5px;
      font-size: 11px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      cursor: pointer;
      border: 1px solid transparent;
      color: var(--muted);
    }

    .item span.label {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .item small {
      font-size: 9px;
      opacity: 0.7;
    }

    .item.active {
      background: var(--accent-soft);
      border-color: var(--accent);
      color: var(--accent);
    }

    .item:hover {
      background: #151822;
      border-color: var(--border-subtle);
    }

    .item .tag {
      padding: 1px 5px;
      border-radius: 999px;
      font-size: 8px;
      border: 1px solid var(--border-subtle);
      color: var(--muted);
    }

    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 10px 14px 8px;
      gap: 8px;
      overflow: hidden;
      min-width: 0;
    }

    .main-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-shrink: 0;
    }

    .main-header-title {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .main-header-title h2 {
      margin: 0;
      font-size: 14px;
      font-weight: 500;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .main-header-title span {
      font-size: 11px;
      color: var(--muted);
    }

    .main-header-actions {
      display: flex;
      gap: 6px;
      align-items: center;
      flex-wrap: wrap;
    }

    .main-header-pill {
      padding: 3px 7px;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      font-size: 9px;
      color: var(--muted);
    }

    .canvas-wrap {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 1fr) 260px;
      gap: 8px;
      align-items: flex-start;
      justify-content: flex-start;
      min-width: 0;
      overflow: hidden;
    }

    .canvas-area {
      background: radial-gradient(circle at top, #171b22, #05070b);
      border-radius: 12px;
      border: 1px solid var(--border-subtle);
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
      overflow: hidden;
    }

    .canvas-toolbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 10px;
      color: var(--muted);
      flex-shrink: 0;
    }

    .canvas-toolbar span strong {
      color: var(--accent);
      font-weight: 500;
    }

    .canvas {
      width: 800px;
      height: 480px;
      margin-top: 4px;
      background: #f5f5f5;
      border-radius: 10px;
      border: 1px solid #d0d0d0;
      position: relative;
      box-shadow: inset 0 0 0 1px #ffffff, 0 18px 40px rgba(0, 0, 0, 0.45);
      overflow: hidden;
      transition: all 0.16s ease;
      flex-shrink: 0;
    }

    .canvas.dark {
      background: #000000;
      border-color: #222222;
      box-shadow: inset 0 0 0 1px #222222, 0 18px 40px rgba(0, 0, 0, 0.7);
    }

    .canvas.landscape {
      width: 800px;
      height: 480px;
    }

    .canvas.portrait {
      width: 480px;
      height: 800px;
    }

    .canvas-grid {
      position: absolute;
      inset: 0;
      background-image:
        linear-gradient(to right, rgba(0, 0, 0, 0.03) 1px, transparent 1px),
        linear-gradient(to bottom, rgba(0, 0, 0, 0.03) 1px, transparent 1px);
      background-size: 20px 20px;
      pointer-events: none;
    }

    .widget {
      position: absolute;
      font-size: 12px;
      color: #000000;
      cursor: move;
      display: block;
      user-select: none;
      -webkit-user-select: none;
      border: none;
      background: transparent;
      padding: 0;
    }

    .widget.active {
      outline: 1px solid var(--accent);
      box-shadow: 0 0 0 1px rgba(82, 199, 234, 0.4);
    }

    .widget-resize-handle {
      position: absolute;
      width: 11px;
      height: 11px;
      border-radius: 3px;
      background: var(--accent);
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.7);
      cursor: nwse-resize;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .widget-resize-handle::after {
      content: "";
      width: 6px;
      height: 2px;
      border-radius: 2px;
      background: #0b0e13;
      transform: rotate(40deg);
      opacity: 0.9;
    }

    .right-panel {
      width: 260px;
      background: #0d1016;
      border-radius: 12px;
      border: 1px solid var(--border-subtle);
      padding: 8px 9px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      box-sizing: border-box;
      max-height: 480px;
      overflow-y: auto;
    }

    .snap-guide {
      position: absolute;
      background: rgba(82, 199, 234, 0.6);
      pointer-events: none;
      z-index: 50;
    }

    .snap-guide-vertical {
      width: 1px;
      top: 0;
      bottom: 0;
    }

    .snap-guide-horizontal {
      height: 1px;
      left: 0;
      right: 0;
    }

    .right-panel h3 {
      margin: 2px 0 2px 0;
      font-size: 10px;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--muted);
    }

    .prop-label {
      font-size: 9px;
      text-transform: uppercase;
      color: var(--muted);
      letter-spacing: 0.12em;
      margin-top: 4px;
      margin-bottom: 2px;
    }

    .prop-input {
      width: 100%;
      padding: 5px 7px;
      font-size: 11px;
      border-radius: 5px;
      border: 1px solid var(--border-subtle);
      background: #05070b;
      color: var(--text);
      outline: none;
    }

    .prop-input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }

    .snippet-area {
      margin-top: 6px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-height: calc(100vh - 520px);
    }

    .snippet-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 4px;
    }

    .snippet-header span {
      font-size: 9px;
      color: var(--muted);
    }

    .snippet-actions {
      display: flex;
      gap: 4px;
      align-items: center;
    }

    .snippet-box {
      flex: 1;
      border-radius: 6px;
      background: #05070b;
      border: 1px solid var(--border-subtle);
      padding: 8px;
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New";
      font-size: 9px;
      color: #d8dee9;
      white-space: pre;
      overflow-y: auto;
      overflow-x: auto;
      max-height: 260px;
    }

    .status-bar {
      font-size: 8px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      gap: 4px;
    }

    .status-bar span.emph {
      color: var(--accent);
    }

    .badge {
      padding: 1px 6px;
      border-radius: 999px;
      border: 1px solid var(--accent);
      color: var(--accent);
      font-size: 8px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    .hidden {
      display: none !important;
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(2, 4, 10, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .modal {
      background: #060910;
      border-radius: 10px;
      border: 1px solid var(--border-subtle);
      padding: 10px;
      width: 90%;
      max-width: 1100px;
      height: 90%;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      color: var(--muted);
    }

    .modal-body {
      flex: 1;
      overflow: auto;
    }

    .modal-body pre {
      white-space: pre;
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New";
      font-size: 10px;
      color: #d8dee9;
    }

    .modal-body textarea {
      width: 100%;
      height: 260px;
      background: #05070b;
      color: #d8dee9;
      border-radius: 6px;
      border: 1px solid var(--border-subtle);
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New";
      font-size: 10px;
      padding: 6px;
      resize: vertical;
    }

    .modal-actions {
      display: flex;
      justify-content: flex-end;
      gap: 6px;
      margin-top: 4px;
    }
  </style>

  <!-- Load Material Design Icons TTF (for editor preview only).
       Works in multiple scenarios (tries in order):
       1) Offline file:// usage -> loads ./materialdesignicons-webfont.ttf next to this HTML file.
       2) ESPHome fonts directory -> /local/esphome/fonts/materialdesignicons-webfont.ttf
       3) Home Assistant /local deployment -> /local/reterminal_dashboard/materialdesignicons-webfont.ttf
       4) HACS deployment -> /hacsfiles/reterminal_dashboard/materialdesignicons-webfont.ttf
       5) Panel view route -> /reterminal-dashboard/materialdesignicons-webfont.ttf
       
       NOTE: Users should place materialdesignicons-webfont.ttf in /config/esphome/fonts/
       for both ESPHome device usage AND editor preview. -->
  <style>
    @font-face {
      font-family: "MDI";
      src:
        url("materialdesignicons-webfont.ttf") format("truetype"),
        url("/local/esphome/fonts/materialdesignicons-webfont.ttf") format("truetype"),
        url("/local/reterminal_dashboard/materialdesignicons-webfont.ttf") format("truetype"),
        url("/hacsfiles/reterminal_dashboard/materialdesignicons-webfont.ttf") format("truetype"),
        url("/reterminal-dashboard/materialdesignicons-webfont.ttf") format("truetype");
      font-weight: normal;
      font-style: normal;
    }

    .mdi-icon-preview {
      font-family: "MDI", system-ui, -apple-system, BlinkMacSystemFont, -sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
    }
  </style>
</head>
<body>
  <aside class="sidebar">
    <div>
      <h1><span class="logo-dot"></span> reTerminal Designer</h1>
      <div class="pill">
        <span></span>
        <div>ESPHome YAML snippet · Local + HA backend</div>
      </div>
    </div>

    <div class="sidebar-group">
      <div class="sidebar-section-label">Target device</div>
      <div class="select" style="display:flex;align-items:center;justify-content:space-between;gap:6px;">
        <div>
          <div style="font-size:11px;color:var(--text);">reTerminal E1001</div>
          <div style="font-size:9px;color:var(--muted);">ESP32-S3 · 800x480 epaper</div>
        </div>
        <div class="badge">MVP</div>
      </div>
      <div class="status-bar">
        <span>Base ESPHome config is managed in ESPHome UI.</span>
      </div>
    </div>

    <div class="sidebar-group">
      <div class="sidebar-section-label">Pages</div>
      <div id="pageList" class="page-list"></div>
      <button id="addPageBtn" class="btn btn-secondary btn-full">+ Add page</button>
    </div>

    <div class="sidebar-group">
      <div class="sidebar-section-label">Widgets</div>
      <div id="widgetPalette" class="widget-list">
        <div class="item" data-widget-type="label">
          <span class="label">Floating text</span>
          <span class="tag">Text</span>
        </div>
        <div class="item" data-widget-type="sensor_text">
          <span class="label">Sensor text</span>
          <span class="tag">Entity</span>
        </div>
        <div class="item" data-widget-type="icon">
          <span class="label">MDI icon</span>
          <span class="tag">Icon</span>
        </div>
        <div class="item" data-widget-type="shape_rect">
          <span class="label">Rectangle / box</span>
          <span class="tag">Shape</span>
        </div>
        <div class="item" data-widget-type="shape_circle">
          <span class="label">Circle</span>
          <span class="tag">Shape</span>
        </div>
        <div class="item" data-widget-type="line">
          <span class="label">Line</span>
          <span class="tag">Shape</span>
        </div>
      </div>
    </div>

    <div class="sidebar-group">
      <button id="saveLayoutBtn" class="btn btn-full">Save layout</button>
      <button id="generateSnippetBtn" class="btn btn-secondary btn-full">Generate ESPHome snippet</button>
      <div class="status-bar" id="sidebarStatus">
        <span>Layout status will appear here.</span>
        <span class="emph">Snippets are additive to your base ESPHome config.</span>
      </div>
    </div>
  </aside>

  <main class="main">
    <div class="main-header">
      <div class="main-header-title">
        <h2>Visual layout editor</h2>
        <span>Each widget on the canvas becomes part of your ESPHome display lambda.</span>
      </div>
      <div class="main-header-actions">
        <div class="main-header-pill">
          Canvas: <span id="canvasSizeLabel">800 x 480</span> px · reTerminal E-Ink
        </div>
        <select id="orientationSelect" class="select" style="width:auto;padding:3px 6px;font-size:9px;" title="Canvas orientation">
          <option value="landscape">Landscape 800x480</option>
          <option value="portrait">Portrait 480x800</option>
        </select>
      </div>
    </div>

    <div class="canvas-wrap">
      <section class="canvas-area">
        <div class="canvas-toolbar">
          <span>Page: <strong id="currentPageName">Loading...</strong></span>
          <span>Place widgets to define what the reTerminal shows.</span>
        </div>
        <div id="canvas" class="canvas">
          <div class="canvas-grid"></div>
        </div>
      </section>

      <aside class="right-panel">
        <h3>Widget properties</h3>
        <div class="field" style="margin-bottom:2px;">
          <div class="prop-label">Editor options</div>
          <label style="display:flex;align-items:center;gap:6px;font-size:9px;color:var(--muted);">
            <input id="snapToggle" type="checkbox" checked style="width:auto;height:auto;margin:0;" />
            <span>Snap to guides</span>
          </label>
        </div>
        <div id="propertiesPanel">
          <div class="field">
            <span style="font-size:9px;color:var(--muted);">
              Select a widget on the canvas to edit its position, size, text, color, fill, shading, and line thickness.
            </span>
          </div>
        </div>
      </aside>
    </div>

    <section class="snippet-area">
      <div class="snippet-header">
        <span>Generated configuration (append below your base ESPHome YAML)</span>
        <div class="snippet-actions">
          <button id="copySnippetBtn" class="btn btn-secondary" style="padding:3px 6px;font-size:9px;">Copy</button>
          <button id="fullscreenSnippetBtn" class="btn btn-secondary" style="padding:3px 6px;font-size:9px;">Fullscreen</button>
          <button id="importSnippetBtn" class="btn btn-secondary" style="padding:3px 6px;font-size:9px;">Import</button>
        </div>
      </div>
      <div id="snippetBox" class="snippet-box">
# Click "Generate ESPHome snippet" to see output here.
# This includes layout and minimal surrounding definitions.
      </div>
      <div class="status-bar">
        <span>Does not include esphome/wifi/api/ota/logger.</span>
        <span>Paste this into ESPHome, then compile and flash.</span>
      </div>
    </section>
  </main>

  <!-- Fullscreen snippet modal -->
  <div id="snippetFullscreenModal" class="modal-backdrop hidden">
    <div class="modal">
      <div class="modal-header">
        <div>ESPHome YAML snippet (fullscreen)</div>
        <button id="snippetFullscreenClose" class="btn btn-secondary">Close</button>
      </div>
      <div class="modal-body">
        <pre id="snippetFullscreenContent"></pre>
      </div>
    </div>
  </div>

  <!-- Import snippet modal -->
  <div id="importSnippetModal" class="modal-backdrop hidden">
    <div class="modal">
      <div class="modal-header">
        <div>Import ESPHome snippet</div>
        <button id="importSnippetCancel" class="btn btn-secondary">Cancel</button>
      </div>
      <div class="modal-body">
        <textarea id="importSnippetTextarea" placeholder="# Paste your ESPHome snippet here"></textarea>
        <div id="importSnippetError" class="prop-label" style="color: var(--danger);"></div>
      </div>
      <div class="modal-actions">
        <button id="importSnippetConfirm" class="btn">Import</button>
      </div>
    </div>
  </div>

  <!-- Page settings modal -->
  <div id="pageSettingsModal" class="modal-backdrop hidden">
    <div class="modal" style="max-width: 500px; height: auto;">
      <div class="modal-header">
        <div>Page Settings</div>
        <button id="pageSettingsClose" class="btn btn-secondary">Close</button>
      </div>
      <div class="modal-body">
        <div class="field">
          <div class="prop-label">Page Name</div>
          <input id="pageSettingsName" class="prop-input" type="text" placeholder="Page name" />
        </div>
        <div class="field">
          <div class="prop-label">Refresh Interval (seconds)</div>
          <input id="pageSettingsRefresh" class="prop-input" type="number" min="0" step="1" placeholder="Auto (uses ESPHome default)" />
          <div style="font-size: 9px; color: var(--muted); margin-top: 2px;">
            Leave empty for default. Set to 0 for manual refresh only. Recommended: 60-300 seconds.
          </div>
        </div>
      </div>
      <div class="modal-actions">
        <button id="pageSettingsSave" class="btn">Save</button>
      </div>
    </div>
  </div>

  <script>
    // --- Environment detection: HA backend vs standalone/offline ---
    function detectHaBackendBaseUrl() {
      try {
        // If served via HA panel or reverse proxy, use relative API base.
        // If running from file:// or static host without HA, fetch will fail and we fall back to offline mode.
        const loc = window.location;
        if (loc.protocol === "file:") {
          return null;
        }
        // If likely under Home Assistant, assume same-origin API.
        // For file:// or plain static hosts without HA, return null so we stay fully offline.
        if (
          loc.hostname === "homeassistant" ||
          loc.hostname === "hassio" ||
          loc.pathname.includes("/api/") ||
          loc.pathname.includes("/local/") ||
          loc.pathname.includes("/hacsfiles/") ||
          loc.pathname.includes("/reterminal-dashboard")
        ) {
          return `${loc.origin}/api/reterminal_dashboard`;
        }
        return null;
      } catch (e) {
        return null;
      }
    }

    const HA_API_BASE = detectHaBackendBaseUrl();

    function hasHaBackend() {
      return !!HA_API_BASE;
    }

    // --- HA Entity States Cache for Live Preview ---
    let entityStatesCache = {};
    let entityStatesFetchInProgress = false;

    async function fetchEntityStates() {
      if (!hasHaBackend()) return;
      if (entityStatesFetchInProgress) return;
      
      entityStatesFetchInProgress = true;
      try {
        const resp = await fetch(`${HA_API_BASE}/entities?domains=sensor,binary_sensor,weather`);
        if (!resp.ok) {
          console.warn("Failed to fetch entity states:", resp.status);
          return;
        }
        const entities = await resp.json();
        if (!Array.isArray(entities)) {
          console.warn("Invalid entity response format");
          return;
        }
        
        // Build a map of entity_id -> state
        const newCache = {};
        for (const entity of entities) {
          if (entity.entity_id && entity.state !== undefined) {
            newCache[entity.entity_id] = entity.state;
          }
        }
        entityStatesCache = newCache;
        
        // Re-render canvas to show updated states
        if (typeof renderCanvas === 'function') {
          renderCanvas();
        }
      } catch (err) {
        console.warn("Error fetching entity states:", err);
      } finally {
        entityStatesFetchInProgress = false;
      }
    }

    function getEntityState(entityId) {
      return entityStatesCache[entityId] || null;
    }

    // Auto-refresh entity states every 30 seconds when HA backend is available
    if (hasHaBackend()) {
      fetchEntityStates(); // Initial fetch
      setInterval(fetchEntityStates, 30000);
    }

    function setImportError(message) {
      const importSnippetError = document.getElementById("importSnippetError");
      if (importSnippetError) {
        importSnippetError.textContent = message || "";
      }
    }

    // Minimal client-side ESPHome YAML snippet parser used for offline mode.
    // This is intentionally scoped to the snippet patterns we generate.
    function parseSnippetYamlOffline(yamlText) {
      // Extremely minimal and permissive parsing:
      // - Detect display: -> waveshare_epaper block
      // - Extract lines inside lambda: |-
      // - Recognize simple drawing primitives and map them to widgets.
      const lines = yamlText.split(/\r?\n/);
      const lambdaLines = [];
      let inLambda = false;
      let lambdaIndent = 0;

      for (const rawLine of lines) {
        const line = rawLine.replace(/\t/g, "    ");

        if (!inLambda && line.match(/^\s*lambda:\s*\|\-/)) {
          inLambda = true;
          // Next indented lines belong to lambda
          continue;
        }

        if (inLambda) {
          // End lambda when indentation is lost on a non-empty line
          if (!line.trim()) {
            // allow blank lines inside lambda
            lambdaLines.push("");
            continue;
          }

          const indentMatch = line.match(/^(\s+)/);
          if (!indentMatch) {
            // no leading spaces -> lambda ended
            inLambda = false;
            continue;
          }

          const indentLen = indentMatch[1].length;
          if (lambdaIndent === 0) {
            // first lambda body line defines base indent
            lambdaIndent = indentLen;
          }

          if (indentLen < lambdaIndent) {
            // dedented -> outside lambda
            inLambda = false;
            continue;
          }

          const stripped = line.slice(lambdaIndent);
          lambdaLines.push(stripped);
        }
      }

      // Strip our own fallback wrapper comments / lines if present so re-import is idempotent.
      // This ignores:
      // - leading comment lines starting with "# Local preview snippet"
      // - trailing comment lines starting with "# Backend unreachable"
      while (lines.length && lines[0].match(/^\s*#\s*Local preview snippet/)) {
        lines.shift();
      }
      while (lines.length && lines[lines.length - 1].match(/^\s*#\s*Backend unreachable/)) {
        lines.pop();
      }

      // Build default single-page layout
      const layout = {
        settings: {
          orientation: "landscape",
          dark_mode: false
        },
        pages: [
          {
            id: "page_0",
            name: "Imported",
            widgets: []
          }
        ]
      };

      const widgets = layout.pages[0].widgets;

      for (const cmd of lambdaLines) {
        const trimmed = cmd.trim();
        if (!trimmed || trimmed.startsWith("//") || trimmed.startsWith("#")) continue;

        // Match patterns like: it.rectangle(10, 10, 100, 50);
        let m;

        // Match patterns like: it.rectangle(x, y, w, h); or it.rectangle(x, y, w, h, COLOR_OFF);
        m = trimmed.match(/^it\.rectangle\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*COLOR_OFF)?\s*\)\s*;?/);
        if (m) {
          widgets.push({
            id: "w_rect_" + widgets.length,
            type: "shape_rect",
            x: parseInt(m[1], 10),
            y: parseInt(m[2], 10),
            width: parseInt(m[3], 10),
            height: parseInt(m[4], 10),
            title: "",
            entity_id: "",
            props: {
              fill: false,
              border_width: 1,
              color: "black",
              opacity: 100
            }
          });
          continue;
        }

        // it.filled_rectangle(x, y, w, h); or with COLOR_OFF
        m = trimmed.match(/^it\.filled_rectangle\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*COLOR_OFF)?\s*\)\s*;?/);
        if (m) {
          widgets.push({
            id: "w_frect_" + widgets.length,
            type: "shape_rect",
            x: parseInt(m[1], 10),
            y: parseInt(m[2], 10),
            width: parseInt(m[3], 10),
            height: parseInt(m[4], 10),
            title: "",
            entity_id: "",
            props: {
              fill: true,
              border_width: 1,
              color: "black",
              opacity: 100
            }
          });
          continue;
        }

        // it.circle(cx, cy, r); or with COLOR_OFF
        m = trimmed.match(/^it\.circle\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*COLOR_OFF)?\s*\)\s*;?/);
        if (m) {
          const r = parseInt(m[3], 10);
          widgets.push({
            id: "w_circle_" + widgets.length,
            type: "shape_circle",
            x: parseInt(m[1], 10) - r,
            y: parseInt(m[2], 10) - r,
            width: r * 2,
            height: r * 2,
            title: "",
            entity_id: "",
            props: {
              fill: false,
              border_width: 1,
              color: "black",
              opacity: 100
            }
          });
          continue;
        }

        // it.filled_circle(cx, cy, r); or with COLOR_OFF
        m = trimmed.match(/^it\.filled_circle\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*COLOR_OFF)?\s*\)\s*;?/);
        if (m) {
          const r = parseInt(m[3], 10);
          widgets.push({
            id: "w_fcircle_" + widgets.length,
            type: "shape_circle",
            x: parseInt(m[1], 10) - r,
            y: parseInt(m[2], 10) - r,
            width: r * 2,
            height: r * 2,
            title: "",
            entity_id: "",
            props: {
              fill: true,
              border_width: 1,
              color: "black",
              opacity: 100
            }
          });
          continue;
        }

        // Simple line pattern: it.line(x1, y1, x2, y2);
        // it.line(x1, y1, x2, y2); (plain only for now)
        m = trimmed.match(/^it\.line\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)\s*;?/);
        if (m) {
          const x1 = parseInt(m[1], 10);
          const y1 = parseInt(m[2], 10);
          const x2 = parseInt(m[3], 10);
          const y2 = parseInt(m[4], 10);
          widgets.push({
            id: "w_line_" + widgets.length,
            type: "line",
            x: x1,
            y: y1,
            width: x2 - x1,
            height: y2 - y1,
            title: "",
            entity_id: "",
            props: {
              stroke_width: 1,
              color: "black"
            }
          });
          continue;
        }

        // Ignore other commands in offline mode.
      }

      return layout;
    }

    // Apply imported layout object (from backend or offline parser) into current editor state.
    function applyImportedLayout(layout) {
      if (!layout || !Array.isArray(layout.pages)) {
        throw new Error("invalid_layout");
      }
      pages = layout.pages.map((p, idx) => ({
        id: p.id || `page_${idx}`,
        name: p.name || `Page ${idx + 1}`,
        widgets: Array.isArray(p.widgets) ? p.widgets : []
      }));
      if (!pages.length) {
        pages = [
          {
            id: "page_0",
            name: "Imported",
            widgets: []
          }
        ];
      }
      settings = layout.settings || settings || {};
      currentPageIndex = 0;
      rebuildWidgetsIndex();
      applyOrientation(settings.orientation || "landscape");
      renderPagesSidebar();
      renderCanvas();
      renderPropertiesPanel();
      scheduleSnippetUpdate();
    }

    // Import handler used by the Import modal confirm button.
    async function handleImportSnippetConfirm() {
      setImportError("");
      const textarea = document.getElementById("importSnippetTextarea");
      if (!textarea) return;
      const yaml = textarea.value || "";
      if (!yaml.trim()) {
        setImportError("Please paste an ESPHome YAML snippet first.");
        return;
      }

      // If HA backend is available, prefer server-side parser for full fidelity.
      if (hasHaBackend()) {
        try {
          const resp = await fetch(`${HA_API_BASE}/import_snippet`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({ yaml })
          });

          if (!resp.ok) {
            const data = await resp.json().catch(() => ({}));
            const msg =
              data.message ||
              data.error ||
              `Home Assistant import_snippet failed with status ${resp.status}`;
            setImportError(msg);
            return;
          }

          const result = await resp.json();
          applyImportedLayout(result);
          closeImportSnippetModal();
          sidebarStatus.innerHTML =
            '<span>Imported layout from snippet via Home Assistant backend.</span>';
          return;
        } catch (err) {
          // On network/host errors (e.g. when opened standalone), fall back to offline parser.
          console.warn("HA import_snippet request failed; falling back to offline parser.", err);
        }
      }

      // Offline / fallback path: parse snippet locally.
      try {
        const offlineLayout = parseSnippetYamlOffline(yaml);
        applyImportedLayout(offlineLayout);
        closeImportSnippetModal();
        sidebarStatus.innerHTML =
          '<span>Imported layout from snippet (offline client-side parser).</span>';
      } catch (err) {
        console.error("Offline snippet import failed", err);
        setImportError(
          "Could not parse snippet offline. Try importing within Home Assistant for full support."
        );
      }
    }

    // Modal helpers used by existing Import button wiring (extended below).
    function openImportSnippetModal() {
      const modal = document.getElementById("importSnippetModal");
      const textarea = document.getElementById("importSnippetTextarea");
      setImportError("");
      if (textarea) {
        textarea.value = "";
      }
      if (modal) {
        modal.classList.remove("hidden");
      }
    }

    function closeImportSnippetModal() {
      const modal = document.getElementById("importSnippetModal");
      if (modal) {
        modal.classList.add("hidden");
      }
    }

    const canvas = document.getElementById("canvas");
    const pageListEl = document.getElementById("pageList");
    const currentPageNameEl = document.getElementById("currentPageName");
    const propertiesPanel = document.getElementById("propertiesPanel");
    const sidebarStatus = document.getElementById("sidebarStatus");
    const snippetBox = document.getElementById("snippetBox");

    const addPageBtn = document.getElementById("addPageBtn");
    const saveLayoutBtn = document.getElementById("saveLayoutBtn");
    const generateSnippetBtn = document.getElementById("generateSnippetBtn");
    const copySnippetBtn = document.getElementById("copySnippetBtn");
    const fullscreenSnippetBtn = document.getElementById("fullscreenSnippetBtn");
    const importSnippetBtn = document.getElementById("importSnippetBtn");

    const snippetFullscreenModal = document.getElementById("snippetFullscreenModal");
    const snippetFullscreenContent = document.getElementById("snippetFullscreenContent");
    const snippetFullscreenClose = document.getElementById("snippetFullscreenClose");

    const importSnippetModal = document.getElementById("importSnippetModal");
    const importSnippetTextarea = document.getElementById("importSnippetTextarea");
    const importSnippetError = document.getElementById("importSnippetError");
    const importSnippetCancel = document.getElementById("importSnippetCancel");
    const importSnippetConfirm = document.getElementById("importSnippetConfirm");

    // --- Wire up import snippet modal and confirm button ---
    if (importSnippetBtn) {
      importSnippetBtn.addEventListener("click", () => {
        openImportSnippetModal();
      });
    }
    if (importSnippetCancel) {
      importSnippetCancel.addEventListener("click", () => {
        closeImportSnippetModal();
      });
    }
    if (importSnippetConfirm) {
      importSnippetConfirm.addEventListener("click", () => {
        // Always go through our dual-mode handler; it will:
        // - Use HA API when available
        // - Otherwise perform offline parsing without any network calls.
        handleImportSnippetConfirm();
      });
    }

    let CANVAS_WIDTH = 800;
    let CANVAS_HEIGHT = 480;

    const SNAP_ENABLED_DEFAULT = true;
    const SNAP_DISTANCE = 10; // px on editor canvas (more generous snapping)
    let snapEnabled = SNAP_ENABLED_DEFAULT;

    let pages = [];
    let settings = {
      orientation: "landscape",
      dark_mode: false
    };
    let currentPageIndex = 0;
    let widgetsById = new Map();
    let selectedWidgetId = null;

    function initDefaultLayout() {
      pages = [
        {
          id: "page_0",
          name: "Overview",
          widgets: []
        }
      ];
      currentPageIndex = 0;
      rebuildWidgetsIndex();
      applyOrientation(settings.orientation || "landscape");
      renderPagesSidebar();
      renderCanvas();
      renderPropertiesPanel();
    }

    function applyOrientation(orientation) {
      settings.orientation = orientation === "portrait" ? "portrait" : "landscape";
      const canvasEl = canvas;
      const sizeLabel = document.getElementById("canvasSizeLabel");
      const orientationSelect = document.getElementById("orientationSelect");
      if (orientationSelect) {
        orientationSelect.value = settings.orientation;
      }
      if (settings.orientation === "portrait") {
        CANVAS_WIDTH = 480;
        CANVAS_HEIGHT = 800;
        canvasEl.classList.remove("landscape");
        canvasEl.classList.add("portrait");
        sizeLabel.textContent = "480 x 800";
      } else {
        CANVAS_WIDTH = 800;
        CANVAS_HEIGHT = 480;
        canvasEl.classList.remove("portrait");
        canvasEl.classList.add("landscape");
        sizeLabel.textContent = "800 x 480";
      }
      canvasEl.style.width = CANVAS_WIDTH + "px";
      canvasEl.style.height = CANVAS_HEIGHT + "px";
      renderCanvas();
    }

    function rebuildWidgetsIndex() {
      widgetsById = new Map();
      for (const page of pages) {
        for (const w of page.widgets) {
          widgetsById.set(w.id, w);
        }
      }
    }

    function getCurrentPage() {
      return pages[currentPageIndex] || pages[0];
    }

    function renderPagesSidebar() {
      pageListEl.innerHTML = "";
      pages.forEach((page, index) => {
        const item = document.createElement("div");
        item.className = "item" + (index === currentPageIndex ? " active" : "");
        
        // Main click: select page
        item.onclick = () => {
          currentPageIndex = index;
          selectedWidgetId = null;
          renderPagesSidebar();
          renderCanvas();
          renderPropertiesPanel();
          scheduleSnippetUpdate();
        };
        
        const label = document.createElement("span");
        label.className = "label";
        label.textContent = page.name;
        const tag = document.createElement("span");
        tag.className = "tag";
        tag.textContent = page.id;
        item.appendChild(label);
        item.appendChild(tag);
        
        // Add edit button for page settings
        const editBtn = document.createElement("button");
        editBtn.textContent = "⚙";
        editBtn.className = "btn btn-secondary";
        editBtn.style.padding = "1px 4px";
        editBtn.style.fontSize = "8px";
        editBtn.style.marginLeft = "auto";
        editBtn.title = "Page settings";
        editBtn.onclick = (e) => {
          e.stopPropagation();
          openPageSettingsModal(page);
        };
        item.appendChild(editBtn);
        
        pageListEl.appendChild(item);
      });
      const page = getCurrentPage();
      currentPageNameEl.textContent = page ? page.name : "None";
    }

    function createWidget(type) {
      const page = getCurrentPage();
      if (!page) return;
      const id = "w_" + Date.now() + "_" + Math.floor(Math.random() * 9999);
      const widget = {
        id,
        type,
        x: 40,
        y: 40,
        width: 120,
        height: 40,
        title: "",
        entity_id: "",
        props: {}
      };

      if (type === "label" || type === "text") {
        widget.type = "text";
        widget.props.text = "Text";
        widget.props.font_size = 20;
        widget.props.color = "black";
      } else if (type === "sensor_text") {
        widget.type = "sensor_text";
        widget.props.font_size = 18;
        widget.props.color = "black";
        widget.entity_id = "sensor.example";
        widget.title = "Sensor";
      } else if (type === "shape_rect") {
        widget.type = "shape_rect";
        widget.props.fill = false;
        widget.props.border_width = 1;
        widget.props.color = "black";
        widget.props.opacity = 100;
      } else if (type === "shape_circle") {
        widget.type = "shape_circle";
        widget.width = 40;
        widget.height = 40;
        widget.props.fill = false;
        widget.props.border_width = 1;
        widget.props.color = "black";
        widget.props.opacity = 100;
      } else if (type === "icon") {
        widget.type = "icon";
        widget.width = 60;
        widget.height = 60;
        // Default Weather-Cloudy icon (F0595) as an example
        widget.props.code = "F0595";
        widget.props.size = 40;
        // Logical font ref; snippet generator will map to font_mdi_medium/font_mdi_large
        widget.props.font_ref = "font_mdi_medium";
        // Editor-only behavior: when true, icon scales to fill its frame while preserving aspect
        widget.props.fit_icon_to_frame = true;
      } else if (type === "line") {
        widget.type = "line";
        widget.width = 80;
        widget.height = 0;
        widget.props.stroke_width = 1;
        widget.props.color = "black";
      }

      page.widgets.push(widget);
      widgetsById.set(widget.id, widget);
      selectedWidgetId = widget.id;
      renderCanvas();
      renderPropertiesPanel();
      scheduleSnippetUpdate();
    }

    function onWidgetPaletteClick(e) {
      const item = e.target.closest(".item[data-widget-type]");
      if (!item) return;
      const type = item.getAttribute("data-widget-type");
      createWidget(type);
    }

    function clearSnapGuides() {
      const guides = canvas.querySelectorAll(".snap-guide");
      guides.forEach((g) => g.remove());
    }

    function addSnapGuideVertical(x) {
      const guide = document.createElement("div");
      guide.className = "snap-guide snap-guide-vertical";
      guide.style.left = `${x}px`;
      canvas.appendChild(guide);
    }

    function addSnapGuideHorizontal(y) {
      const guide = document.createElement("div");
      guide.className = "snap-guide snap-guide-horizontal";
      guide.style.top = `${y}px`;
      canvas.appendChild(guide);
    }

    function getSnapLines(excludeWidgetId) {
      const page = getCurrentPage();
      const vertical = [];
      const horizontal = [];

      // Canvas edges and centers
      vertical.push(0, CANVAS_WIDTH / 2, CANVAS_WIDTH);
      horizontal.push(0, CANVAS_HEIGHT / 2, CANVAS_HEIGHT);

      if (page && Array.isArray(page.widgets)) {
        for (const w of page.widgets) {
          if (!w || w.id === excludeWidgetId) continue;
          const left = w.x;
          const right = w.x + (w.width || 0);
          const top = w.y;
          const bottom = w.y + (w.height || 0);
          const cx = left + (w.width || 0) / 2;
          const cy = top + (w.height || 0) / 2;
          vertical.push(left, cx, right);
          horizontal.push(top, cy, bottom);
        }
      }

      return {
        vertical,
        horizontal
      };
    }

    function applySnapToPosition(widget, x, y, ev) {
      if (!snapEnabled || (ev && ev.altKey)) {
        clearSnapGuides();
        return { x: Math.round(x), y: Math.round(y) };
      }

      const page = getCurrentPage();
      if (!page) {
        clearSnapGuides();
        return { x: Math.round(x), y: Math.round(y) };
      }

      const snapLines = getSnapLines(widget.id);
      const w = widget.width || 0;
      const h = widget.height || 0;

      const left = x;
      const right = x + w;
      const cx = x + w / 2;
      const top = y;
      const bottom = y + h;
      const cy = y + h / 2;

      let snappedX = x;
      let snappedY = y;
      let snappedV = null;
      let snappedH = null;

      // Vertical snapping (left, center, right)
      const vCandidates = [
        { val: left, offset: (val, line) => line, apply: (line) => (snappedX = line) },
        { val: cx, offset: (val, line) => line - w / 2, apply: (line) => (snappedX = line - w / 2) },
        { val: right, offset: (val, line) => line - w, apply: (line) => (snappedX = line - w) }
      ];

      let bestDeltaV = SNAP_DISTANCE + 1;
      for (const cand of vCandidates) {
        for (const line of snapLines.vertical) {
          const delta = Math.abs(cand.val - line);
          if (delta <= SNAP_DISTANCE && delta < bestDeltaV) {
            bestDeltaV = delta;
            snappedV = line;
            cand.apply(line);
          }
        }
      }

      // Horizontal snapping (top, center, bottom)
      const hCandidates = [
        { val: top, apply: (line) => (snappedY = line) },
        { val: cy, apply: (line) => (snappedY = line - h / 2) },
        { val: bottom, apply: (line) => (snappedY = line - h) }
      ];

      let bestDeltaH = SNAP_DISTANCE + 1;
      for (const cand of hCandidates) {
        for (const line of snapLines.horizontal) {
          const delta = Math.abs(cand.val - line);
          if (delta <= SNAP_DISTANCE && delta < bestDeltaH) {
            bestDeltaH = delta;
            snappedH = line;
            cand.apply(line);
          }
        }
      }

      snappedX = Math.max(0, Math.min(CANVAS_WIDTH - w, snappedX));
      snappedY = Math.max(0, Math.min(CANVAS_HEIGHT - h, snappedY));

      clearSnapGuides();
      if (snappedV != null) addSnapGuideVertical(snappedV);
      if (snappedH != null) addSnapGuideHorizontal(snappedH);

      return {
        x: Math.round(snappedX),
        y: Math.round(snappedY)
      };
    }

    function renderCanvas() {
      const page = getCurrentPage();
      // Preserve existing widgets when re-rendering to keep current drag guides visible.
      // We only clear existing widget elements and keep the grid and any active snap guides.
      const existingGrid = canvas.querySelector(".canvas-grid");
      const existingGuides = canvas.querySelectorAll(".snap-guide");
      canvas.innerHTML = "";
      if (existingGrid) canvas.appendChild(existingGrid);
      existingGuides.forEach((g) => canvas.appendChild(g));
      if (!page) return;

      for (const widget of page.widgets) {
        const el = document.createElement("div");
        el.className = "widget";
        el.style.left = widget.x + "px";
        el.style.top = widget.y + "px";
        el.style.width = widget.width + "px";
        el.style.height = widget.height + "px";
        el.dataset.id = widget.id;

        if (widget.id === selectedWidgetId) {
          el.classList.add("active");
        }

        const type = (widget.type || "").toLowerCase();
        const props = widget.props || {};

        if (type === "icon") {
          const code = (props.code || "").trim().toUpperCase();
          const sizeManual = parseInt(props.size || 40, 10) || 40;
          const hex = code && code.match(/^F[0-9A-F]{3}$/i) ? code : "F0595";
          const cp = 0xf0000 + parseInt(hex.slice(1), 16);
          const ch = String.fromCodePoint(cp);

          const fit = !!props.fit_icon_to_frame;
          el.classList.add("mdi-icon-preview");
          el.style.fontFamily = "MDI, system-ui, -apple-system, BlinkMacSystemFont, -sans-serif";
          el.style.lineHeight = "1";
          el.style.color = "#000000";

          if (fit) {
            const padding = 4;
            const maxW = Math.max(8, (widget.width || 0) - padding * 2);
            const maxH = Math.max(8, (widget.height || 0) - padding * 2);
            const size = Math.max(8, Math.min(maxW, maxH));
            el.style.display = "flex";
            el.style.alignItems = "center";
            el.style.justifyContent = "center";
            el.style.fontSize = size + "px";
          } else {
            el.style.fontSize = sizeManual + "px";
          }

          el.textContent = ch;
        } else if (type === "shape_rect" || type === "shape_circle" || type === "line") {
          const color = props.color || "black";
          const borderWidth = parseInt(props.border_width != null ? props.border_width : 1, 10);
          const fill = !!props.fill;
          const opacityVal = parseInt(props.opacity != null ? props.opacity : 100, 10);
          const opacity = Math.max(0, Math.min(100, isNaN(opacityVal) ? 100 : opacityVal)) / 100;
          const strokeWidthVal = parseInt(
            props.stroke_width != null ? props.stroke_width : (borderWidth || 1),
            10
          );
          const strokeWidth = Math.max(1, isNaN(strokeWidthVal) ? 1 : strokeWidthVal);

          const colorValue =
            color === "white"
              ? "#ffffff"
              : color === "gray"
              ? "#aaaaaa"
              : "#000000";

          if (type === "shape_rect") {
            el.style.boxSizing = "border-box";
            el.style.border = borderWidth > 0 ? borderWidth + "px solid " + colorValue : "none";
            el.style.backgroundColor = fill ? colorValue : "transparent";
            el.style.opacity = fill ? opacity : 1;
          } else if (type === "shape_circle") {
            el.style.boxSizing = "border-box";
            el.style.borderRadius = "999px";
            el.style.border = borderWidth > 0 ? borderWidth + "px solid " + colorValue : "none";
            el.style.backgroundColor = fill ? colorValue : "transparent";
            el.style.opacity = fill ? opacity : 1;
          } else if (type === "line") {
            el.style.boxSizing = "border-box";
            el.style.height = strokeWidth + "px";
            el.style.width = (widget.width || 80) + "px";
            el.style.backgroundColor = colorValue;
          }
        } else {
          const fontSize = props.font_size || 16;
          const color = props.color || "black";
          const opacityVal = parseInt(props.opacity != null ? props.opacity : 100, 10);
          const opacity = Math.max(0, Math.min(100, isNaN(opacityVal) ? 100 : opacityVal)) / 100;

          const body = document.createElement("div");
          body.style.fontSize = fontSize + "px";
          body.style.color =
            color === "white"
              ? "#ffffff"
              : color === "gray"
              ? "#aaaaaa"
              : "#000000";
          body.style.opacity = opacity;

          let text = "";
          if (type === "sensor_text") {
            const entityId = widget.entity_id || "";
            if (hasHaBackend() && entityId) {
              const state = getEntityState(entityId);
              if (state !== null) {
                text = state;
              } else {
                text = widget.title || entityId || "sensor";
              }
            } else {
              text = widget.title || entityId || "sensor";
            }
          } else {
            text = props.text || widget.title || "Text";
          }

          body.textContent = text;
          el.appendChild(body);
        }

        const handle = document.createElement("div");
        handle.className = "widget-resize-handle";
        el.appendChild(handle);

        el.addEventListener("mousedown", (ev) => onWidgetMouseDown(ev, widget.id));
        canvas.appendChild(el);
      }
    }

    function renderPropertiesPanel() {
      const panel = propertiesPanel;
      panel.innerHTML = "";

      const widget = selectedWidgetId ? widgetsById.get(selectedWidgetId) : null;
      if (!widget) {
        const info = document.createElement("div");
        info.className = "field";
        info.innerHTML =
          '<span style="font-size:9px;color:var(--muted);">Select a widget on the canvas to edit its properties.</span>';
        panel.appendChild(info);
        return;
      }

      const type = (widget.type || "").toLowerCase();
      widget.props = widget.props || {};

      function addLabeledInput(label, typeAttr, value, onChange) {
        const wrap = document.createElement("div");
        wrap.className = "field";
        const lbl = document.createElement("div");
        lbl.className = "prop-label";
        lbl.textContent = label;
        const inp = document.createElement("input");
        inp.className = "prop-input";
        inp.type = typeAttr;
        inp.value = value != null ? value : "";
        inp.addEventListener("input", () => {
          onChange(inp.value);
          scheduleSnippetUpdate();
        });
        wrap.appendChild(lbl);
        wrap.appendChild(inp);
        panel.appendChild(wrap);
        return inp;
      }

      function addSelect(label, value, options, onChange) {
        const wrap = document.createElement("div");
        wrap.className = "field";
        const lbl = document.createElement("div");
        lbl.className = "prop-label";
        lbl.textContent = label;
        const sel = document.createElement("select");
        sel.className = "prop-input";
        options.forEach((optVal) => {
          const opt = document.createElement("option");
          opt.value = optVal;
          opt.textContent = optVal;
          if (optVal === value) opt.selected = true;
          sel.appendChild(opt);
        });
        sel.addEventListener("change", () => {
          onChange(sel.value);
          scheduleSnippetUpdate();
        });
        wrap.appendChild(lbl);
        wrap.appendChild(sel);
        panel.appendChild(wrap);
        return sel;
      }

      addLabeledInput("Position X", "number", widget.x, (v) => {
        widget.x = parseInt(v || "0", 10) || 0;
        renderCanvas();
      });
      addLabeledInput("Position Y", "number", widget.y, (v) => {
        widget.y = parseInt(v || "0", 10) || 0;
        renderCanvas();
      });

      if (type === "line") {
        addLabeledInput("dx (line width)", "number", widget.width, (v) => {
          widget.width = parseInt(v || "0", 10) || 0;
          renderCanvas();
        });
        addLabeledInput("dy (line height)", "number", widget.height, (v) => {
          widget.height = parseInt(v || "0", 10) || 0;
          renderCanvas();
        });
      } else {
        addLabeledInput("Width", "number", widget.width, (v) => {
          widget.width = parseInt(v || "0", 10) || 0;
          renderCanvas();
        });
        addLabeledInput("Height", "number", widget.height, (v) => {
          widget.height = parseInt(v || "0", 10) || 0;
          renderCanvas();
        });
      }

      if (type === "icon") {
        const fitWrap = document.createElement("div");
        fitWrap.className = "field";
        const fitLbl = document.createElement("div");
        fitLbl.className = "prop-label";
        fitLbl.textContent = "Fit icon to frame";
        const fitCb = document.createElement("input");
        fitCb.type = "checkbox";
        fitCb.checked = !!widget.props.fit_icon_to_frame;
        fitCb.addEventListener("change", () => {
          widget.props.fit_icon_to_frame = fitCb.checked;
          renderCanvas();
          scheduleSnippetUpdate();
        });
        fitWrap.appendChild(fitLbl);
        fitWrap.appendChild(fitCb);
        panel.appendChild(fitWrap);

        addLabeledInput("MDI Unicode (Fxxxx)", "text", widget.props.code || "F0595", (v) => {
          const clean = (v || "").trim().toUpperCase().replace(/^0X/, "");
          if (/^F[0-9A-F]{3}$/i.test(clean)) {
            widget.props.code = clean;
          } else {
            widget.props.code = "F0595";
          }
          renderCanvas();
        });

        addLabeledInput("Icon size (px)", "number", widget.props.size || 40, (v) => {
          let n = parseInt(v || "40", 10);
          if (Number.isNaN(n) || n < 8) n = 8;
          if (n > 260) n = 260;
          widget.props.size = n;
          // Only relevant when not fitting to frame; still allow editing for compatibility.
          renderCanvas();
        });

        addSelect(
          "Font reference",
          widget.props.font_ref || "font_mdi_medium",
          ["font_mdi_medium", "font_mdi_large"],
          (val) => {
            widget.props.font_ref = val;
            renderCanvas();
          }
        );
      }

      if (["text", "sensor_text"].includes(type)) {
        if (type === "text") {
          addLabeledInput("Text", "text", widget.props.text || "", (v) => {
            widget.props.text = v;
            renderCanvas();
          });
        }
        if (type === "sensor_text") {
          // Entity ID with picker button
          const entityWrap = document.createElement("div");
          entityWrap.className = "field";
          const entityLbl = document.createElement("div");
          entityLbl.className = "prop-label";
          entityLbl.textContent = "Entity ID";
          
          const entityRow = document.createElement("div");
          entityRow.style.display = "flex";
          entityRow.style.gap = "4px";
          
          const entityInput = document.createElement("input");
          entityInput.className = "prop-input";
          entityInput.type = "text";
          entityInput.value = widget.entity_id || "";
          entityInput.style.flex = "1";
          entityInput.addEventListener("input", () => {
            widget.entity_id = entityInput.value;
            renderCanvas();
            scheduleSnippetUpdate();
          });
          
          const pickerBtn = document.createElement("button");
          pickerBtn.className = "btn btn-secondary";
          pickerBtn.textContent = "⋮⋮⋮";
          pickerBtn.style.padding = "5px 8px";
          pickerBtn.style.fontSize = "10px";
          pickerBtn.type = "button";
          pickerBtn.title = "Pick from Home Assistant entities";
          pickerBtn.addEventListener("click", () => {
            openEntityPickerForWidget(widget, entityInput);
          });
          
          entityRow.appendChild(entityInput);
          entityRow.appendChild(pickerBtn);
          entityWrap.appendChild(entityLbl);
          entityWrap.appendChild(entityRow);
          panel.appendChild(entityWrap);
          
          addLabeledInput("Label", "text", widget.title || "", (v) => {
            widget.title = v;
            renderCanvas();
          });
        }
        addLabeledInput("Font size", "number", widget.props.font_size || 16, (v) => {
          widget.props.font_size = parseInt(v || "16", 10) || 16;
          renderCanvas();
        });
        addSelect("Text color", widget.props.color || "black", ["black", "white", "gray"], (val) => {
          widget.props.color = val;
          renderCanvas();
        });
      }

      if (type === "shape_rect" || type === "shape_circle") {
        const fillWrap = document.createElement("div");
        fillWrap.className = "field";
        const fillLbl = document.createElement("div");
        fillLbl.className = "prop-label";
        fillLbl.textContent = "Fill shape";
        const fillCb = document.createElement("input");
        fillCb.type = "checkbox";
        fillCb.checked = !!widget.props.fill;
        fillCb.addEventListener("change", () => {
          widget.props.fill = fillCb.checked;
          renderCanvas();
          scheduleSnippetUpdate();
        });
        fillWrap.appendChild(fillLbl);
        fillWrap.appendChild(fillCb);
        panel.appendChild(fillWrap);

        addLabeledInput(
          "Border width (px)",
          "number",
          widget.props.border_width != null ? widget.props.border_width : 1,
          (v) => {
            let n = parseInt(v || "1", 10);
            if (Number.isNaN(n) || n < 0) n = 0;
            widget.props.border_width = n;
            renderCanvas();
          }
        );

        addSelect(
          "Shape color",
          widget.props.color || "black",
          ["black", "white", "gray"],
          (val) => {
            widget.props.color = val;
            renderCanvas();
          }
        );

        addLabeledInput(
          "Fill opacity (0-100)",
          "number",
          widget.props.opacity != null ? widget.props.opacity : 100,
          (v) => {
            let n = parseInt(v || "100", 10);
            if (Number.isNaN(n)) n = 100;
            widget.props.opacity = Math.max(0, Math.min(100, n));
            renderCanvas();
          }
        );
      }

      if (type === "line") {
        addLabeledInput(
          "Stroke width (px)",
          "number",
          widget.props.stroke_width != null ? widget.props.stroke_width : 1,
          (v) => {
            let n = parseInt(v || "1", 10);
            if (Number.isNaN(n) || n < 1) n = 1;
            widget.props.stroke_width = n;
            renderCanvas();
          }
        );
        addSelect(
          "Line color",
          widget.props.color || "black",
          ["black", "white", "gray"],
          (val) => {
            widget.props.color = val;
            renderCanvas();
          }
        );
      }
    }

    function screenToCanvasPosition(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      let x = clientX - rect.left;
      let y = clientY - rect.top;
      x = Math.max(0, Math.min(CANVAS_WIDTH - 10, x));
      y = Math.max(0, Math.min(CANVAS_HEIGHT - 10, y));
      return { x, y };
    }

    let dragState = null;

    function onWidgetMouseDown(ev, widgetId) {
      const widget = widgetsById.get(widgetId);
      if (!widget) return;
      selectedWidgetId = widgetId;
      renderCanvas();
      renderPropertiesPanel();

      const target = ev.target;
      const rect = canvas.getBoundingClientRect();

      if (target.classList.contains("widget-resize-handle")) {
        dragState = {
          mode: "resize",
          id: widgetId,
          startX: ev.clientX,
          startY: ev.clientY,
          startW: widget.width,
          startH: widget.height
        };
      } else {
        dragState = {
          mode: "move",
          id: widgetId,
          offsetX: ev.clientX - (rect.left + widget.x),
          offsetY: ev.clientY - (rect.top + widget.y)
        };
      }

      window.addEventListener("mousemove", onMouseMove);
      window.addEventListener("mouseup", onMouseUp);
      ev.preventDefault();
    }

    function onMouseMove(ev) {
      if (!dragState) return;
      const widget = widgetsById.get(dragState.id);
      if (!widget) return;

      // Ensure canvas keeps grid element for guide positioning
      if (!canvas.querySelector(".canvas-grid")) {
        const grid = document.createElement("div");
        grid.className = "canvas-grid";
        canvas.insertBefore(grid, canvas.firstChild || null);
      }

      if (dragState.mode === "move") {
        const rect = canvas.getBoundingClientRect();
        let x = ev.clientX - rect.left - dragState.offsetX;
        let y = ev.clientY - rect.top - dragState.offsetY;
        x = Math.max(0, Math.min(CANVAS_WIDTH - widget.width, x));
        y = Math.max(0, Math.min(CANVAS_HEIGHT - widget.height, y));

        const snapped = applySnapToPosition(widget, x, y, ev);
        widget.x = snapped.x;
        widget.y = snapped.y;
      } else if (dragState.mode === "resize") {
        let w = dragState.startW + (ev.clientX - dragState.startX);
        let h = dragState.startH + (ev.clientY - dragState.startY);
        w = Math.max(10, Math.min(CANVAS_WIDTH - widget.x, w));
        h = Math.max(10, Math.min(CANVAS_HEIGHT - widget.y, h));
        widget.width = Math.round(w);
        widget.height = Math.round(h);
      }

      // Live redraw of only the moved widget to keep snap preview smooth.
      // Full render + properties update are deferred to mouseup for performance.
      renderCanvas();
    }

    function onMouseUp() {
      dragState = null;
      clearSnapGuides();
      window.removeEventListener("mousemove", onMouseMove);
      window.removeEventListener("mouseup", onMouseUp);
      // Now commit: re-render everything and properties, then update snippet.
      renderCanvas();
      renderPropertiesPanel();
      scheduleSnippetUpdate();
    }

    function getPagesPayload() {
      return {
        device_id: "reterminal_e1001",
        name: "reTerminal E1001",
        current_page: currentPageIndex,
        pages
      };
    }

    // Local fallback snippet: simple but multiline and structured
    function generateSnippetLocally() {
      const payload = getPagesPayload();
      const pagesLocal = payload.pages || [];
      const lines = [];

      // Collect all icon glyphs in use
      const iconCodes = new Set();
      for (const page of pagesLocal) {
        if (!page || !Array.isArray(page.widgets)) continue;
        for (const w of page.widgets) {
          const t = (w.type || "").toLowerCase();
          const p = w.props || {};
          if (t === "icon") {
            const raw = (p.code || "").trim().toUpperCase().replace(/^0X/, "");
            if (/^F[0-9A-F]{3}$/i.test(raw)) {
              iconCodes.add(raw);
            }
          }
        }
      }

      lines.push("# Local preview snippet (fallback)");
      lines.push("# Paste below your base ESPHome config.");
      lines.push("# IMPORTANT: Ensure 'materialdesignicons-webfont.ttf' is placed in your ESPHome config:");
      lines.push("#   /config/esphome/fonts/materialdesignicons-webfont.ttf");
      lines.push("# Then keep the 'file: fonts/materialdesignicons-webfont.ttf' path below.");
      lines.push("");

      if (iconCodes.size > 0) {
        lines.push("font:");
        lines.push("  # Icon fonts used by MDI icon widgets generated from the reTerminal editor.");
        lines.push("  - file: 'fonts/materialdesignicons-webfont.ttf'");
        lines.push("    id: font_mdi_large");
        lines.push("    size: 200");
        lines.push("    glyphs: &mdi_glyphs");
        iconCodes.forEach((code) => {
          const hex = code.toUpperCase();
          const full = "000" + hex;
          lines.push(`      - "\\U000${full}"`);
        });
        lines.push("  - file: 'fonts/materialdesignicons-webfont.ttf'");
        lines.push("    id: font_mdi_medium");
        lines.push("    size: 40");
        lines.push("    glyphs: *mdi_glyphs");
        lines.push("");
      }

      lines.push("globals:");
      lines.push("  - id: display_page");
      lines.push("    type: int");
      lines.push("    restore_value: true");
      lines.push("    initial_value: '0'");
      lines.push("");
      lines.push("display:");
      lines.push("  - platform: waveshare_epaper");
      lines.push("    id: epaper_display");
      lines.push("    model: 7.50in-bV3");
      lines.push("    update_interval: 0s");
      lines.push("    lambda: |-");
      lines.push("      int page = id(display_page);");

      pagesLocal.forEach((page, pageIndex) => {
        lines.push(`      if (page == ${pageIndex}) {`);
        if (!page.widgets || !page.widgets.length) {
          lines.push("        // No widgets on this page.");
        } else {
          for (const w of page.widgets) {
            const t = (w.type || "").toLowerCase();
            const p = w.props || {};
            // Local preview mirrors backend yaml_generator.py as closely as possible.
            if (t === "text" || t === "label") {
              const txt = (p.text || w.title || "Text").replace(/"/g, '\\"');
              if (!txt) continue;
              const color = p.color === "white" ? "COLOR_ON" : "COLOR_OFF";
              lines.push(`        it.print(${w.x}, ${w.y}, id(font_normal), ${color}, "${txt}");`);
            } else if (t === "icon") {
              const raw = (p.code || "").trim().toUpperCase().replace(/^0X/, "");
              if (!/^F[0-9A-F]{3}$/i.test(raw)) continue;
              const hex = raw.toUpperCase();
              const full = "000" + hex;
              const glyphEsc = `\\U000${full}`;
              const fontRef = p.font_ref === "font_mdi_large" ? "font_mdi_large" : "font_mdi_medium";
              lines.push(
                `        it.printf(${w.x}, ${w.y}, id(${fontRef}), TextAlign::CENTER, "${glyphEsc}");`
              );
            } else if (t === "shape_rect") {
              const color = p.color === "white" ? "COLOR_ON" : "COLOR_OFF";
              const fill = !!p.fill;
              const borderWidth = parseInt(p.border_width || 1, 10) || 1;
              if (fill) {
                lines.push(`        it.filled_rectangle(${w.x}, ${w.y}, ${w.width}, ${w.height}, ${color});`);
                if (borderWidth > 1) {
                  lines.push(`        it.rectangle(${w.x}, ${w.y}, ${w.width}, ${w.height}, ${color});`);
                }
              } else {
                if (borderWidth <= 1) {
                  lines.push(`        it.rectangle(${w.x}, ${w.y}, ${w.width}, ${w.height}, ${color});`);
                } else {
                  lines.push(`        // rectangle with border_width=${borderWidth}`);
                  lines.push(`        for (int i = 0; i < ${borderWidth}; i++) {`);
                  lines.push(
                    `          it.rectangle(${w.x}+i, ${w.y}+i, ${w.width}-2*i, ${w.height}-2*i, ${color});`
                  );
                  lines.push("        }");
                }
              }
            } else if (t === "shape_circle") {
              const color = p.color === "white" ? "COLOR_ON" : "COLOR_OFF";
              const wSafe = Math.max(1, w.width || 1);
              const hSafe = Math.max(1, w.height || 1);
              const r = Math.max(1, Math.floor(Math.min(wSafe, hSafe) / 2));
              const cx = w.x + Math.floor(wSafe / 2);
              const cy = w.y + Math.floor(hSafe / 2);
              const fill = !!p.fill;
              const borderWidth = parseInt(p.border_width || 1, 10) || 1;
              if (fill) {
                lines.push(`        it.filled_circle(${cx}, ${cy}, ${r}, ${color});`);
                if (borderWidth > 1) {
                  lines.push(`        it.circle(${cx}, ${cy}, ${r}, ${color});`);
                }
              } else {
                if (borderWidth <= 1) {
                  lines.push(`        it.circle(${cx}, ${cy}, ${r}, ${color});`);
                } else {
                  lines.push(`        // circle with border_width=${borderWidth}`);
                  lines.push(`        for (int i = 0; i < ${borderWidth}; i++) {`);
                  lines.push(`          it.circle(${cx}, ${cy}, ${r}-i, ${color});`);
                  lines.push("        }");
                }
              }
            } else if (t === "line") {
              const color = p.color === "white" ? "COLOR_ON" : "COLOR_OFF";
              const dx = w.width || 0;
              const dy = w.height || 0;
              const x2 = w.x + dx;
              const y2 = w.y + dy;
              const strokeWidth = parseInt(p.stroke_width || 1, 10) || 1;
              if (strokeWidth <= 1) {
                lines.push(`        it.line(${w.x}, ${w.y}, ${x2}, ${y2}, ${color});`);
              } else {
                lines.push(`        // line with stroke_width=${strokeWidth}`);
                lines.push("        for (int i = 0; i < " + strokeWidth + "; i++) {");
                lines.push(`          it.line(${w.x}, ${w.y}+i, ${x2}, ${y2}+i, ${color});`);
                lines.push("        }");
              }
            }
          }
        }
        lines.push("      }");
      });

      return lines.join("\n");
    }

    async function updateSnippet(preferBackend = true) {
      if (!snippetBox) return;

      const local = generateSnippetLocally();

      if (!preferBackend) {
        snippetBox.textContent = local + "\n# Local preview (no backend).";
        return;
      }

      try {
        const resp = await fetch("/api/reterminal_dashboard/snippet", { method: "GET" });
        if (!resp.ok) {
          throw new Error("HTTP " + resp.status);
        }
        const text = await resp.text();
        snippetBox.textContent = (text && text.trim()) ? text : "# Empty snippet";
      } catch (err) {
        snippetBox.textContent =
          local + "\n# Backend unreachable, showing local preview only.";
      }
    }

    let snippetDebounceTimer = null;
    function scheduleSnippetUpdate() {
      if (!snippetBox) return;
      if (snippetDebounceTimer) clearTimeout(snippetDebounceTimer);
      snippetDebounceTimer = setTimeout(() => {
        updateSnippet(true);
      }, 300);
    }

    document.getElementById("widgetPalette").addEventListener("click", onWidgetPaletteClick);

    const snapToggleEl = document.getElementById("snapToggle");
    if (snapToggleEl) {
      snapToggleEl.checked = snapEnabled;
      snapToggleEl.addEventListener("change", () => {
        snapEnabled = !!snapToggleEl.checked;
        clearSnapGuides();
      });
    }

    // --- HA-backed entity picker support ---

    let haEntitiesCache = null;
    let haEntitiesLoaded = false;
    let haEntitiesLoadError = false;

    async function loadHaEntitiesIfNeeded() {
      if (!hasHaBackend || !hasHaBackend()) {
        haEntitiesLoadError = true;
        return [];
      }
      if (haEntitiesLoaded && haEntitiesCache) {
        return haEntitiesCache;
      }
      try {
        const resp = await fetch(`${HA_API_BASE}/entities?domains=sensor,binary_sensor,weather`);
        if (!resp.ok) {
          throw new Error("HTTP " + resp.status);
        }
        const data = await resp.json();
        if (!Array.isArray(data)) {
          throw new Error("Invalid response format");
        }
        haEntitiesCache = data;
        haEntitiesLoaded = true;
        return haEntitiesCache;
      } catch (err) {
        console.warn("Failed to load entities for picker; falling back to manual input.", err);
        haEntitiesLoadError = true;
        return [];
      }
    }

    function openEntityPickerForWidget(widget, inputEl) {
      // If loading previously failed or no backend, do nothing (manual entry only).
      if (!hasHaBackend || !hasHaBackend() || haEntitiesLoadError) {
        return;
      }

      const container = propertiesPanel;
      // Remove any existing picker
      const existing = container.querySelector(".entity-picker-overlay");
      if (existing) {
        existing.remove();
      }

      const overlay = document.createElement("div");
      overlay.className = "entity-picker-overlay";
      overlay.style.marginTop = "4px";
      overlay.style.padding = "4px";
      overlay.style.borderRadius = "6px";
      overlay.style.border = "1px solid var(--border-subtle)";
      overlay.style.background = "#05070b";
      overlay.style.display = "flex";
      overlay.style.flexDirection = "column";
      overlay.style.gap = "4px";
      overlay.style.maxHeight = "160px";
      overlay.style.overflow = "hidden";

      const header = document.createElement("div");
      header.style.display = "flex";
      header.style.justifyContent = "space-between";
      header.style.alignItems = "center";
      header.style.gap = "4px";
      header.style.fontSize = "8px";
      header.style.color = "var(--muted)";
      header.textContent = "Pick Home Assistant entity";

      const closeBtn = document.createElement("button");
      closeBtn.className = "btn btn-secondary";
      closeBtn.textContent = "×";
      closeBtn.style.padding = "0 4px";
      closeBtn.style.fontSize = "9px";
      closeBtn.type = "button";
      closeBtn.addEventListener("click", () => {
        overlay.remove();
      });

      const headerRight = document.createElement("div");
      headerRight.style.display = "flex";
      headerRight.style.alignItems = "center";
      headerRight.style.gap = "4px";
      headerRight.appendChild(closeBtn);

      const headerWrap = document.createElement("div");
      headerWrap.style.display = "flex";
      headerWrap.style.justifyContent = "space-between";
      headerWrap.style.alignItems = "center";
      headerWrap.style.gap = "4px";
      headerWrap.appendChild(header);
      headerWrap.appendChild(headerRight);

      const searchRow = document.createElement("div");
      searchRow.style.display = "flex";
      searchRow.style.gap = "4px";
      searchRow.style.alignItems = "center";

      const searchInput = document.createElement("input");
      searchInput.type = "text";
      searchInput.className = "prop-input";
      searchInput.placeholder = "Search name or entity_id";
      searchInput.style.flex = "1";

      const domainSelect = document.createElement("select");
      domainSelect.className = "prop-input";
      domainSelect.style.width = "80px";
      ["all", "sensor", "binary_sensor", "weather"].forEach((d) => {
        const opt = document.createElement("option");
        opt.value = d;
        opt.textContent = d;
        domainSelect.appendChild(opt);
      });

      searchRow.appendChild(searchInput);
      searchRow.appendChild(domainSelect);

      const list = document.createElement("div");
      list.style.flex = "1";
      list.style.overflowY = "auto";
      list.style.borderRadius = "4px";
      list.style.border = "1px solid var(--border-subtle)";
      list.style.padding = "2px";
      list.style.fontSize = "8px";

      overlay.appendChild(headerWrap);
      overlay.appendChild(searchRow);
      overlay.appendChild(list);
      container.appendChild(overlay);

      function renderList(entities) {
        list.innerHTML = "";
        if (!entities || entities.length === 0) {
          const empty = document.createElement("div");
          empty.style.color = "var(--muted)";
          empty.textContent = "No entities match.";
          list.appendChild(empty);
          return;
        }
        entities.forEach((e) => {
          const row = document.createElement("div");
          row.style.display = "flex";
          row.style.flexDirection = "column";
          row.style.padding = "2px 3px";
          row.style.borderRadius = "3px";
          row.style.cursor = "pointer";

          row.addEventListener("mouseenter", () => {
            row.style.background = "#0d1118";
          });
          row.addEventListener("mouseleave", () => {
            row.style.background = "transparent";
          });

          const name = document.createElement("div");
          name.style.fontSize = "8px";
          name.style.color = "var(--text)";
          name.textContent = e.name || e.entity_id;

          const meta = document.createElement("div");
          meta.style.fontSize = "7px";
          meta.style.color = "var(--muted)";
          meta.textContent = `${e.entity_id} · ${e.domain}`;

          row.appendChild(name);
          row.appendChild(meta);

          row.addEventListener("click", () => {
            widget.entity_id = e.entity_id;
            if (!widget.title) {
              widget.title = e.name || "";
            }
            inputEl.value = widget.entity_id;
            renderCanvas();
            renderPropertiesPanel();
            scheduleSnippetUpdate();
            overlay.remove();
          });

          list.appendChild(row);
        });
      }

      // Load entities and wire filters
      loadHaEntitiesIfNeeded().then((entities) => {
        if (!entities || entities.length === 0) {
          renderList([]);
          return;
        }

        function applyFilter() {
          const q = (searchInput.value || "").toLowerCase();
          const dom = domainSelect.value;
          const filtered = entities.filter((e) => {
            if (dom !== "all" && e.domain !== dom) {
              return false;
            }
            if (!q) return true;
            const hay = `${e.entity_id} ${e.name || ""}`.toLowerCase();
            return hay.includes(q);
          });
          renderList(filtered);
        }

        searchInput.addEventListener("input", applyFilter);
        domainSelect.addEventListener("change", applyFilter);

        applyFilter();
      });
    }

    const orientationSelectEl = document.getElementById("orientationSelect");
    if (orientationSelectEl) {
      orientationSelectEl.addEventListener("change", () => {
        applyOrientation(orientationSelectEl.value);
        scheduleSnippetUpdate();
      });
    }

    addPageBtn.onclick = () => {
      const id = "page_" + pages.length;
      pages.push({ id, name: "Page " + (pages.length + 1), widgets: [] });
      currentPageIndex = pages.length - 1;
      rebuildWidgetsIndex();
      renderPagesSidebar();
      renderCanvas();
      renderPropertiesPanel();
      scheduleSnippetUpdate();
    };

    saveLayoutBtn.onclick = async () => {
      const body = getPagesPayload();
      try {
        const resp = await fetch("/api/reterminal_dashboard/layout", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body)
        });
        if (!resp.ok) {
          sidebarStatus.textContent = "Failed to save layout via API.";
          return;
        }
        sidebarStatus.textContent = "Layout saved.";
        scheduleSnippetUpdate();
      } catch {
        sidebarStatus.textContent = "Failed to save layout (network error).";
      }
    };

    if (generateSnippetBtn) {
      generateSnippetBtn.addEventListener("click", async () => {
        await updateSnippet(true);
      });
    }

    copySnippetBtn.onclick = async () => {
      const text = snippetBox.textContent || "";
      try {
        await navigator.clipboard.writeText(text);
        sidebarStatus.textContent = "Snippet copied to clipboard.";
      } catch {
        sidebarStatus.textContent = "Unable to copy snippet.";
      }
    };

    fullscreenSnippetBtn.onclick = () => {
      snippetFullscreenContent.textContent = snippetBox.textContent || "";
      snippetFullscreenModal.classList.remove("hidden");
    };

    snippetFullscreenClose.onclick = () => {
      snippetFullscreenModal.classList.add("hidden");
    };

    importSnippetBtn.onclick = () => {
      importSnippetTextarea.value = "";
      importSnippetError.textContent = "";
      importSnippetModal.classList.remove("hidden");
    };

    importSnippetCancel.onclick = () => {
      importSnippetModal.classList.add("hidden");
      importSnippetError.textContent = "";
    };

    importSnippetConfirm.onclick = async () => {
      const yaml = importSnippetTextarea.value;
      if (!yaml.trim()) {
        importSnippetError.textContent = "Paste a snippet first.";
        return;
      }
      try {
        const resp = await fetch("/api/reterminal_dashboard/import_snippet", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ yaml })
        });
        const data = await resp.json().catch(() => ({}));
        if (!resp.ok) {
          importSnippetError.textContent = data.message || data.error || "Import failed.";
          return;
        }
        pages = data.pages || [];
        currentPageIndex = data.current_page || 0;
        selectedWidgetId = null;
        rebuildWidgetsIndex();
        renderPagesSidebar();
        renderCanvas();
        renderPropertiesPanel();
        importSnippetModal.classList.add("hidden");
        importSnippetError.textContent = "";
        scheduleSnippetUpdate();
      } catch (err) {
        importSnippetError.textContent = "Network or server error during import.";
      }
    };

    // Page settings modal
    let currentPageSettingsTarget = null;

    function openPageSettingsModal(page) {
      currentPageSettingsTarget = page;
      const modal = document.getElementById("pageSettingsModal");
      const nameInput = document.getElementById("pageSettingsName");
      const refreshInput = document.getElementById("pageSettingsRefresh");
      
      if (nameInput) nameInput.value = page.name || "";
      if (refreshInput) {
        refreshInput.value = (page.refresh_s != null && page.refresh_s > 0) ? page.refresh_s : "";
      }
      
      if (modal) modal.classList.remove("hidden");
    }

    function closePageSettingsModal() {
      const modal = document.getElementById("pageSettingsModal");
      if (modal) modal.classList.add("hidden");
      currentPageSettingsTarget = null;
    }

    function savePageSettings() {
      if (!currentPageSettingsTarget) return;
      
      const nameInput = document.getElementById("pageSettingsName");
      const refreshInput = document.getElementById("pageSettingsRefresh");
      
      if (nameInput) {
        currentPageSettingsTarget.name = nameInput.value || "Page";
      }
      
      if (refreshInput) {
        const val = refreshInput.value.trim();
        if (val === "") {
          currentPageSettingsTarget.refresh_s = null;
        } else {
          const num = parseInt(val, 10);
          currentPageSettingsTarget.refresh_s = (num >= 0) ? num : null;
        }
      }
      
      renderPagesSidebar();
      scheduleSnippetUpdate();
      closePageSettingsModal();
    }

    // Wire up page settings modal
    const pageSettingsClose = document.getElementById("pageSettingsClose");
    const pageSettingsSave = document.getElementById("pageSettingsSave");
    if (pageSettingsClose) {
      pageSettingsClose.addEventListener("click", closePageSettingsModal);
    }
    if (pageSettingsSave) {
      pageSettingsSave.addEventListener("click", savePageSettings);
    }

    async function loadLayoutFromBackend() {
      try {
        const resp = await fetch("/api/reterminal_dashboard/layout");
        if (!resp.ok) {
          initDefaultLayout();
          return;
        }
        const data = await resp.json();
        pages = data.pages || [];
        currentPageIndex = data.current_page || 0;
        if (!pages.length) {
          initDefaultLayout();
          return;
        }
        rebuildWidgetsIndex();
        renderPagesSidebar();
        renderCanvas();
        renderPropertiesPanel();
      } catch {
        initDefaultLayout();
      }
    }

    loadLayoutFromBackend().then(() => {
      updateSnippet(true);
      // Load entities for picker if HA backend is available
      loadHaEntitiesIfNeeded().catch(err => {
        console.warn("Entity loading failed during init:", err);
      });
    });
  </script>
</body>
</html>