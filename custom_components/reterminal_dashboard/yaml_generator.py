"""
YAML snippet generator for the reTerminal Dashboard Designer integration.

This module takes the internal layout model (DeviceConfig / PageConfig / WidgetConfig)
and produces ESPHome-compatible YAML snippets that the user can paste BELOW an
existing base ESPHome config.

Key principles:
- We DO NOT emit:
  - esphome:
  - esp32:
  - wifi:
  - api:
  - ota:
  - logger:
- We ONLY emit additive blocks:
  - globals, fonts, outputs, rtttl, sensors, text_sensors, scripts, display, etc.
- We target the reTerminal E1001 epaper (800x480) as the initial device.

The output is a single YAML snippet string containing:
- Header comments explaining how to use it.
- Behavior/config blocks (buttons, scripts, etc).
- Layout block(s) mapping configured pages/widgets to display lambda code.

NOTE: This is an MVP generator:
- Focus on safe, deterministic output.
- Supports a conservative subset of widget types.
- Uses IDs and structures inspired by the working reference in:
  resources/ESPHome Reterminal/reterminalE-1001-esphome.txt
"""

from __future__ import annotations

from typing import List

from .models import DeviceConfig, PageConfig, WidgetConfig
from .const import IMAGE_WIDTH, IMAGE_HEIGHT


SNIPPET_HEADER = """# ============================================================
# Generated by reTerminal Dashboard Designer
# Target device: reTerminal E1001 (800x480 epaper)
#
# Usage:
# 1. Ensure you already have a working base ESPHome config for your device:
#    - Includes: esphome, esp32, wifi, api, ota, logger
#    - Uses the correct board for the reTerminal E1001
# 2. Paste this snippet BELOW your existing base config.
# 3. Do NOT duplicate esphome:, wifi:, api:, ota:, logger: sections.
# 4. If you already define conflicting ids (e.g. epaper_display), adjust accordingly.
#
# WARNING:
# - This is an MVP generator. Review the result before flashing.
# - Keep this snippet under version control to track your layout changes.
# ============================================================
"""


def generate_snippet(device: DeviceConfig) -> str:
    """
    Generate a complete YAML snippet for the given device configuration.

    The snippet includes:
    - Required globals/fonts/outputs/rtttl/buttons/sensors/scripts for navigation.
    - A display: epaper_display block with lambda that renders all pages/widgets.

    This function assumes:
    - Single device_type: reTerminal E1001.
    - IMAGE_WIDTH/IMAGE_HEIGHT match the target display (800x480).
    """
    device.ensure_pages()

    parts: List[str] = [SNIPPET_HEADER.rstrip(), ""]

    # Core pieces (ordered for readability)
    # NOTE: output, rtttl, sensor, time are provided by hardware template
    # We only generate: globals, fonts, text_sensor, button, script, display
    parts.append(_generate_globals())
    parts.append(_generate_fonts(device))  # Pass device to collect icon glyphs
    parts.append(_generate_text_sensors(device))  # Only text_sensors for HA entities
    parts.append(_generate_online_images(device))
    parts.append(_generate_navigation_buttons(device))
    parts.append(_generate_scripts(device))
    parts.append(_generate_display_block(device))

    # Join with double newlines between major sections
    return "\n\n".join(p for p in parts if p.strip())


def _generate_globals() -> str:
    return """globals:
  # Current page index (0-based)
  - id: display_page
    type: int
    restore_value: true
    initial_value: '0'

  # Battery icon glyph (optional usage in display lambda)
  - id: battery_glyph
    type: std::string
    restore_value: no
    initial_value: '"\\U000F0079"'

  # Default page refresh interval (seconds)
  - id: page_refresh_default_s
    type: int
    restore_value: no
    initial_value: '900'

  # Current computed refresh interval (seconds)
  - id: page_refresh_current_s
    type: int
    restore_value: no
    initial_value: '900'
"""


def _generate_fonts(device: DeviceConfig) -> str:
    """
    Generate font definitions including Material Design Icons fonts for icon widgets.
    Collects all icon codes from the device and generates appropriate MDI fonts.
    Also generates image definitions for image widgets.
    """
    # Collect all unique icon codes from icon widgets
    icon_codes = set()
    # Collect all unique image paths from image widgets and icon sizes
    image_paths = {}
    icon_sizes = set()  # Track unique icon sizes
    text_sizes = set()  # Track unique text font sizes
    
    for page in device.pages:
        for widget in page.widgets:
            wtype = (widget.type or "").lower()
            if wtype == "icon":
                props = widget.props or {}
                code = props.get("code", "").strip()
                if code:
                    icon_codes.add(code)
                # Collect icon size if specified
                size = int(props.get("size", 48) or 48)
                icon_sizes.add(size)
            elif wtype == "battery_icon":
                # Battery icons need all battery level glyphs
                props = widget.props or {}
                # Add all battery icon codes
                for code in ["F0079", "F007A", "F007B", "F007C", "F007D", "F007E", "F007F", "F0080", "F0081", "F0082"]:
                    icon_codes.add(code)
                # Collect icon size if specified
                size = int(props.get("size", 48) or 48)
                icon_sizes.add(size)
            elif wtype in ("text", "label"):
                props = widget.props or {}
                # Collect text font size if specified
                size = int(props.get("font_size", 0) or 0)
                if size > 0:
                    text_sizes.add(size)
            elif wtype == "image":
                props = widget.props or {}
                path = props.get("path", "").strip()
                if path:
                    # Generate safe ID from path
                    safe_id = path.replace("/", "_").replace(".", "_").replace("-", "_").replace(" ", "_")
                    safe_id = f"img_{safe_id}"
                    # Store path with dimensions for resize
                    width = widget.width or 100
                    height = widget.height or 100
                    image_paths[path] = {"id": safe_id, "width": width, "height": height}
    
    # Base fonts (Inter) - always include the standard sizes
    font_lines = [
        "font:",
        "  - file: \"gfonts://Inter@400\"",
        "    id: font_small",
        "    size: 19",
        "",
        "  - file: \"gfonts://Inter@500\"",
        "    id: font_normal",
        "    size: 22",
        "",
        "  - file: \"gfonts://Inter@700\"",
        "    id: font_header",
        "    size: 24"
    ]
    
    # Add custom text fonts for non-standard sizes
    if text_sizes:
        font_lines.append("")
        font_lines.append("  # Custom text fonts for specific sizes")
        for size in sorted(text_sizes):
            # Skip if it matches our standard sizes closely
            if size in (19, 22, 24):
                continue
            # Choose weight based on size
            if size < 18:
                weight = "400"  # Regular
            elif size < 25:
                weight = "500"  # Medium
            else:
                weight = "700"  # Bold
            font_lines.extend([
                f"  - file: \"gfonts://Inter@{weight}\"",
                f"    id: font_text_{size}",
                f"    size: {size}"
            ])
    
    # Add MDI fonts if there are icon widgets
    if icon_codes:
        # Convert codes to Unicode escapes
        glyphs = []
        for code in sorted(icon_codes):
            # code is like "F0595" - convert to "\U000F0595"
            glyphs.append(f'"\\U000{code}"')
        
        glyph_list = ", ".join(glyphs)
        
        # Generate fonts for each unique size
        if not icon_sizes:
            icon_sizes = {48}  # Default size
        
        font_lines.extend([
            "",
            "  # Material Design Icons for icon widgets",
            "  # Copy materialdesignicons-webfont.ttf to your ESPHome fonts folder"
        ])
        
        # Generate a font for each unique size
        for size in sorted(icon_sizes):
            # Always use size-specific ID for consistency
            font_id = f"font_mdi_{size}"
            
            font_lines.extend([
                "  - file: fonts/materialdesignicons-webfont.ttf",
                f"    id: {font_id}",
                f"    size: {size}",
                f"    glyphs: [{glyph_list}]"
            ])
    
    result = "\n".join(font_lines)
    
    # Add image definitions if there are image widgets
    if image_paths:
        result += "\n\n\nimage:"
        for path, img_data in sorted(image_paths.items()):
            img_id = img_data["id"]
            width = img_data["width"]
            height = img_data["height"]
            result += f"\n  - file: \"{path}\""
            result += f"\n    id: {img_id}"
            result += f"\n    resize: {width}x{height}"
            result += "\n    type: BINARY"
            result += "\n    dither: FLOYDSTEINBERG"
    
    return result


# Removed _generate_outputs_and_buzzer() - now in hardware template


def _generate_text_sensors(device: DeviceConfig) -> str:
    """
    Generate text_sensor and sensor blocks for HomeAssistant entities.
    - text_sensor: for sensor_text widgets (string values)
    - sensor: for progress_bar, battery_icon (numeric values)
    """
    # Collect entity_ids by type
    text_entity_ids = set()
    numeric_entity_ids = set()
    
    for page in device.pages:
        for widget in page.widgets:
            entity_id = (widget.entity_id or "").strip()
            if not entity_id:
                continue
            
            wtype = (widget.type or "").lower()
            # Widgets that need numeric (float) values
            if wtype in ("progress_bar", "battery_icon"):
                numeric_entity_ids.add(entity_id)
            # Widgets that can use text values
            else:
                text_entity_ids.add(entity_id)
    
    sections = []
    
    # Generate text_sensor section for text-based widgets
    if text_entity_ids:
        text_entries = []
        for entity_id in sorted(text_entity_ids):
            safe_id = entity_id.replace(".", "_").replace("-", "_")
            text_entries.append(f"""  - platform: homeassistant
    id: {safe_id}
    entity_id: {entity_id}
    internal: true""")
        
        sections.append(f"""text_sensor:
{chr(10).join(text_entries)}""")
    
    # Generate sensor section for numeric widgets
    if numeric_entity_ids:
        numeric_entries = []
        for entity_id in sorted(numeric_entity_ids):
            safe_id = entity_id.replace(".", "_").replace("-", "_")
            numeric_entries.append(f"""  - platform: homeassistant
    id: {safe_id}
    entity_id: {entity_id}
    internal: true""")
        
        sections.append(f"""sensor:
{chr(10).join(numeric_entries)}""")
    
    if not sections:
        return "# No widgets with entities configured"
    
    return "\n\n".join(sections) + "\n"


def _generate_navigation_buttons(device: DeviceConfig) -> str:
    # Template buttons for navigation and refresh.
    # These operate on display_page and let HA/ESPHome automations drive page changes.
    num_pages = len(device.pages)
    
    # Start with basic navigation buttons
    buttons = ["""button:
  - platform: template
    name: "reTerminal Next Page"
    id: reterminal_next_page
    on_press:
      - lambda: |-
          int pages = {pages};
          id(display_page) = (id(display_page) + 1) % pages;

  - platform: template
    name: "reTerminal Previous Page"
    id: reterminal_prev_page
    on_press:
      - lambda: |-
          int pages = {pages};
          id(display_page) = (id(display_page) - 1 + pages) % pages;

  - platform: template
    name: "reTerminal Refresh Display"
    id: reterminal_refresh_display
    on_press:
      - component.update: epaper_display
""".format(pages=num_pages)]
    
    # Add "Go to Page X" buttons for each page
    for idx in range(num_pages):
        page_name = device.pages[idx].name if hasattr(device.pages[idx], 'name') and device.pages[idx].name else f"Page {idx}"
        buttons.append(f"""
  - platform: template
    name: "reTerminal Go to {page_name}"
    id: reterminal_goto_page_{idx}
    on_press:
      - lambda: 'id(display_page) = {idx};'
      - component.update: epaper_display""")
    
    # Add buzzer control buttons (hardware feature - always included)
    buttons.append("""

  # Buzzer control buttons (hardware feature)
  - platform: template
    name: "reTerminal Beep"
    id: reterminal_beep
    on_press:
      - rtttl.play: "beep:d=32,o=5,b=200:16e6"

  - platform: template
    name: "reTerminal Beep Error"
    id: reterminal_beep_error
    on_press:
      - rtttl.play: "error:d=16,o=5,b=200:c6"

  - platform: template
    name: "reTerminal Play Star Wars"
    id: reterminal_star_wars
    on_press:
      - rtttl.play: "StarWars:d=4,o=5,b=45:32p,32f,32f,32f,8a#.,8f.6,32d#,32d,32c,8a#.6,4f.6,32d#,32d,32c,8a#.6,4f.6,32d#,32d,32d#,8c6,32p,32f,32f,32f,8a#.,8f.6,32d#,32d,32c,8a#.6,4f.6,32d#,32d,32c,8a#.6,4f.6,32d#,32d,32d#,8c6"
""")
    
    return "".join(buttons)


def _generate_scripts(device: DeviceConfig) -> str:
    """
    Generate time + manage_run_and_sleep script with per-page refresh support.

    Semantics:
    - A global default interval (page_refresh_default_s).
    - Inline switch(page) using PageConfig.refresh_s values when provided.
    - Enforce a minimum of 60 seconds for any effective interval.
    """
    case_lines: List[str] = []
    for idx, page in enumerate(device.pages):
        refresh = getattr(page, "refresh_s", None)
        if refresh is None:
            continue
        try:
            val = int(refresh)
        except (TypeError, ValueError):
            continue
        if val >= 60:
            case_lines.append(f"                  case {idx}: interval = {val}; break;")

    if case_lines:
        cases_block = "\n".join(case_lines)
    else:
        cases_block = "                  default:\n                    break;"

    return f"""script:
  - id: manage_run_and_sleep
    mode: restart
    then:
      - if:
          condition:
            lambda: 'return id(ha_time).now().is_valid();'
          then:
            - lambda: |-
                int page = id(display_page);
                int interval = id(page_refresh_default_s);
                switch (page) {{
{cases_block}
                }}
                if (interval < 60) {{
                  interval = 60;
                }}
                id(page_refresh_current_s) = interval;
                ESP_LOGI("refresh", "Next refresh in %d seconds for page %d", interval, page);
            - delay: !lambda 'return id(page_refresh_current_s) * 1000;'
            - component.update: epaper_display
            - script.execute: manage_run_and_sleep
          else:
            - delay: 300s
            - component.update: epaper_display
            - script.execute: manage_run_and_sleep
"""


def _generate_display_block(device: DeviceConfig) -> str:
    """
    Generate the display: epaper_display block with a lambda that:
    - Reads current display_page.
    - Draws widgets belonging to the active page.
    - Uses DeviceConfig.orientation to pick rotation:
        - landscape -> rotation: 0
        - portrait  -> rotation: 90
    - DeviceConfig.dark_mode is advisory; widget-level color/invert decide actual draws.
    """
    lines: List[str] = []

    orientation = getattr(device, "orientation", "landscape")
    if orientation == "portrait":
        rotation = 90
    else:
        rotation = 0

    lines.append("display:")
    lines.append("  - platform: waveshare_epaper")
    lines.append("    id: epaper_display")
    lines.append("    model: 7.50inv2")
    lines.append("    cs_pin: GPIO10")
    lines.append("    dc_pin: GPIO11")
    lines.append("    reset_pin:")
    lines.append("      number: GPIO12")
    lines.append("      inverted: false")
    lines.append("    busy_pin:")
    lines.append("      number: GPIO13")
    lines.append("      inverted: true")
    lines.append("    update_interval: never")
    lines.append("    lambda: |-")
    lines.append("      it.fill(Color(0));")
    lines.append("")

    for page_index, page in enumerate(device.pages):
        _append_page_render(lines, page_index, page)

    return "\n".join(lines)


def _generate_online_images(device: DeviceConfig) -> str:
    """
    Generate `online_image:` blocks for widgets of type `online_image`.
    Each widget becomes an `online_image` entry with an id derived from the widget id.
    """
    image_widgets = []
    for pidx, page in enumerate(device.pages):
        for widget in page.widgets:
            if (widget.type or "").lower() == "online_image":
                image_widgets.append((pidx, widget))

    if not image_widgets:
        return "# No online_image widgets configured"

    lines: List[str] = ["# Remote/puppet images (online_image)"]
    for pidx, widget in image_widgets:
        props = widget.props or {}
        url = (props.get("url") or "").strip()
        interval = int(props.get("interval_s") or 300)
        # Safe id for ESPHome
        safe_id = f"img_{widget.id}".replace("-", "_")
        lines.append(f"online_image:\n  - id: {safe_id}")
        if url:
            lines.append(f"    url: \"{url}\"")
        lines.append(f"    format: PNG")
        lines.append(f"    type: BINARY")
        lines.append(f"    update_interval: {interval}s")
        # on_download_finished: update epaper_display when this page is visible
        lines.append("    on_download_finished:")
        lines.append("      then:")
        lines.append(f"        - logger.log: \"Puppet image downloaded for widget {widget.id}\"")
        lines.append("        - component.update: epaper_display")

    return "\n".join(lines)


def _append_page_render(dst: List[str], page_index: int, page: PageConfig) -> None:
    indent = "      "
    dst.append(f'{indent}if (id(display_page) == {page_index}) {{')
    if not page.widgets:
        dst.append(f"{indent}  // Page {page_index}: no widgets configured.")
    else:
        for widget in page.widgets:
            _append_widget_render(dst, indent + "  ", widget)
    dst.append(f"{indent}}}")


def _resolve_font(props: dict) -> str:
    """Pick a font id based on optional font_size hint in widget props."""
    try:
        size = int(props.get("font_size", 0))
    except (TypeError, ValueError):
        size = 0

    if size <= 0:
        return "id(font_normal)"
    
    # Use exact size font if it's custom
    if size not in (19, 22, 24):
        return f"id(font_text_{size})"
    
    # Map to standard fonts
    if size == 19:
        return "id(font_small)"
    if size == 22:
        return "id(font_normal)"
    if size == 24:
        return "id(font_header)"
    
    # Fallback logic for unspecified sizes
    if size < 20:
        return "id(font_small)"
    if size < 26:
        return "id(font_normal)"
    return "id(font_header)"


def _resolve_font_by_size(size: int) -> str:
    """Pick a font id based on explicit font size value."""
    if size < 20:
        return "id(font_small)"
    if size < 26:
        return "id(font_normal)"
    return "id(font_header)"


def _wrap_with_condition(dst: List[str], indent: str, widget: WidgetConfig, content_lines: List[str]) -> None:
    """Wrap widget rendering code with conditional visibility if configured."""
    has_condition = (
        widget.condition_entity and 
        widget.condition_state is not None and 
        widget.condition_operator
    )
    
    if not has_condition:
        # No condition - just append content
        dst.extend(content_lines)
        return
    
    # Generate safe ID from entity_id for condition
    safe_cond_id = widget.condition_entity.replace(".", "_").replace("-", "_")
    cond_state = str(widget.condition_state).replace('"', '\\"')
    cond_op = widget.condition_operator or "=="
    
    # Map operators to C++ comparisons
    if cond_op == "==":
        # String comparison for equality
        dst.append(f'{indent}if (id({safe_cond_id}).state == "{cond_state}") {{')
        dst.extend(content_lines)
        dst.append(f'{indent}}}')
    elif cond_op == "!=":
        dst.append(f'{indent}if (id({safe_cond_id}).state != "{cond_state}") {{')
        dst.extend(content_lines)
        dst.append(f'{indent}}}')
    elif cond_op in (">", "<", ">=", "<="):
        # Numeric comparison
        dst.append(f'{indent}{{')
        dst.append(f'{indent}  float cond_val = atof(id({safe_cond_id}).state.c_str());')
        dst.append(f'{indent}  if (cond_val {cond_op} {cond_state}) {{')
        # Content needs extra indent
        indented_content = [line.replace(indent, indent + "    ", 1) if line.startswith(indent) else "    " + line for line in content_lines]
        dst.extend(indented_content)
        dst.append(f'{indent}  }}')
        dst.append(f'{indent}}}')


def _append_widget_render(dst: List[str], indent: str, widget: WidgetConfig) -> None:
    """Render a single widget into display lambda C++ code.

    Unified styling semantics:
    - type: "text" / "label"
    - type: "sensor" / "sensor_text"
    - type: "datetime"
    - type: "progress_bar"
    - type: "battery_icon"
    - type: "shape_rect"
    - type: "shape_circle"
    - type: "line"
    - type: "image"
    - type: "history"
    
    Supports conditional visibility based on entity state.
    """
    # Clamp to canvas
    x = max(0, min(widget.x, IMAGE_WIDTH))
    y = max(0, min(widget.y, IMAGE_HEIGHT))
    w = max(1, min(widget.width, IMAGE_WIDTH - x))
    h = max(1, min(widget.height, IMAGE_HEIGHT - y))

    wtype = (widget.type or "text").lower()
    props = widget.props or {}

    # Determine base color polarity from props.color and invert.
    base_color = (props.get("color") or "").lower()
    # E-Paper: COLOR_ON = black ink, COLOR_OFF = white (no ink)
    if base_color == "white":
        fg = "COLOR_OFF"  # White = no ink
    elif base_color == "gray":
        # For grayscale we still use black ink; left for future patterns.
        fg = "COLOR_ON"
    else:
        # Default to black ink
        fg = "COLOR_ON"

    if props.get("invert"):
        fg = "COLOR_OFF" if fg == "COLOR_ON" else "COLOR_ON"

    # Collect widget rendering code, then wrap with condition if needed
    content: List[str] = []

    # Floating text (no box)
    if wtype in ("label", "text"):
        text = (props.get("text") or widget.title or "").replace('"', '\\"')
        if not text:
            return
        font = _resolve_font(props)
        font_size = int(props.get("font_size", 12) or 12)
        color_prop = (props.get("color") or "black").lower()
        font_style = props.get("font_style") or "regular"
        # Add marker comment for parser with all properties
        content.append(f'{indent}// widget:text id:{widget.id} type:text x:{x} y:{y} w:{w} h:{h} text:"{text}" font_size:{font_size} color:{color_prop} font_style:{font_style}')
        content.append(f'{indent}it.print({x}, {y}, {font}, {fg}, "{text}");')
        _wrap_with_condition(dst, indent, widget, content)
        return

    # Icon widget (MDI icon from font)
    if wtype == "icon":
        code = (props.get("code") or "F0595").strip().upper()
        # Validate code format (Fxxx)
        if not code.startswith("F") or len(code) != 5:
            code = "F0595"  # Default to weather-cloudy
        # Convert to unicode codepoint
        try:
            hex_val = int(code[1:], 16)
            codepoint = 0xF0000 + hex_val
            icon_char = chr(codepoint)
        except (ValueError, OverflowError):
            icon_char = chr(0xF0595)  # Fallback
        
        # Determine font based on size - always use size-specific ID
        size = int(props.get("size", 48) or 48)
        font_id = f"font_mdi_{size}"
        
        # Always use the calculated font_id, ignore any stored font_ref (could be outdated)
        font_ref = font_id
        
        # Handle color property - icon widgets have their own color, don't use base fg
        color_prop = (props.get("color") or "black").lower()
        if color_prop == "white":
            icon_color = "COLOR_OFF"
        elif color_prop == "gray":
            icon_color = "COLOR_ON"  # E-paper doesn't have gray, use black
        else:  # black or default
            icon_color = "COLOR_ON"
        
        # Escape special characters
        escaped_char = icon_char.replace("\\", "\\\\").replace('"', '\\"')
        # Add marker comment for parser
        content.append(f'{indent}// widget:icon id:{widget.id} type:icon x:{x} y:{y} w:{w} h:{h} code:{code} size:{size} color:{color_prop}')
        content.append(f'{indent}it.print({x}, {y}, id({font_ref}), {icon_color}, "{escaped_char}");')
        _wrap_with_condition(dst, indent, widget, content)
        return

    # Sensor text (label + value from HA sensor)
    if wtype in ("sensor", "sensor_text"):
        entity_id = (widget.entity_id or "").strip()
        label = (widget.title or "").replace('"', '\\"')
        value_format = props.get("value_format", "label_value")
        label_font_size = int(props.get("label_font_size", 14) or 14)
        value_font_size = int(props.get("value_font_size", 20) or 20)
        value_format = props.get("value_format", "label_value")
        
        if entity_id:
            # Generate safe ID from entity_id
            safe_id = entity_id.replace(".", "_").replace("-", "_")
            
            # Add marker comment for parser with font sizes
            content.append(f'{indent}// widget:sensor_text id:{widget.id} type:sensor_text x:{x} y:{y} w:{w} h:{h} ent:{entity_id} title:"{label}" label_font:{label_font_size} value_font:{value_font_size} format:{value_format}')
            
            if value_format == "label_newline_value" and label:
                # Label on one line, value on another - use separate fonts
                label_font = _resolve_font_by_size(label_font_size)
                value_font = _resolve_font_by_size(value_font_size)
                # Print label
                content.append(f'{indent}it.printf({x}, {y}, {label_font}, {fg}, "{label}");')
                # Print value below label (approximate line height)
                value_y = y + label_font_size + 4
                content.append(f'{indent}it.printf({x}, {value_y}, {value_font}, {fg}, "%s", id({safe_id}).state.c_str());')
            elif value_format == "label_value" and label:
                # Inline format: "Label: Value" - use average size or value size
                font = _resolve_font_by_size(value_font_size)
                content.append(f'{indent}it.printf({x}, {y}, {font}, {fg}, "{label}: %s", id({safe_id}).state.c_str());')
            else:
                # value_only or no label - just show value
                font = _resolve_font_by_size(value_font_size)
                content.append(f'{indent}it.printf({x}, {y}, {font}, {fg}, "%s", id({safe_id}).state.c_str());')
        else:
            # No entity_id configured - show placeholder
            placeholder = label or "sensor"
            font = _resolve_font_by_size(value_font_size)
            # Add marker comment for parser with font sizes
            content.append(f'{indent}// widget:sensor_text id:{widget.id} type:sensor_text x:{x} y:{y} w:{w} h:{h} title:"{label}" label_font:{label_font_size} value_font:{value_font_size} format:{value_format}')
            content.append(f'{indent}// No entity_id configured for this sensor_text widget')
            content.append(f'{indent}it.printf({x}, {y}, {font}, {fg}, "{placeholder}: N/A");')
        _wrap_with_condition(dst, indent, widget, content)
        return

    # Date/time widget
    if wtype == "datetime":
        format_type = props.get("format", "time_date")
        time_font_size = int(props.get("time_font_size", 28) or 28)
        date_font_size = int(props.get("date_font_size", 16) or 16)
        
        time_font = _resolve_font_by_size(time_font_size)
        date_font = _resolve_font_by_size(date_font_size)
        
        # Add marker comment for parser
        content.append(f'{indent}// widget:datetime id:{widget.id} type:datetime x:{x} y:{y} w:{w} h:{h} format:{format_type} time_font:{time_font_size} date_font:{date_font_size}')
        
        if format_type == "time_only":
            # Time only - centered
            content.append(f'{indent}it.strftime({x}, {y}, {time_font}, {fg}, "%H:%M", id(ha_time).now());')
        elif format_type == "date_only":
            # Date only - centered
            content.append(f'{indent}it.strftime({x}, {y}, {date_font}, {fg}, "%a, %b %d", id(ha_time).now());')
        else:
            # time_date - time on top, date below
            content.append(f'{indent}it.strftime({x}, {y}, {time_font}, {fg}, "%H:%M", id(ha_time).now());')
            date_y = y + time_font_size + 4
            content.append(f'{indent}it.strftime({x}, {date_y}, {date_font}, {fg}, "%a, %b %d", id(ha_time).now());')
        _wrap_with_condition(dst, indent, widget, content)
        return

    # Progress bar widget
    if wtype == "progress_bar":
        entity_id = (widget.entity_id or "").strip()
        label = (widget.title or "").replace('"', '\\"')
        show_label = props.get("show_label", True)
        show_percentage = props.get("show_percentage", True)
        bar_height = int(props.get("bar_height", 15) or 15)
        border_width = int(props.get("border_width", 1) or 1)
        
        if not entity_id:
            # No entity configured - show placeholder
            content.append(f'{indent}// widget:progress_bar id:{widget.id} (no entity configured)')
            content.append(f'{indent}it.rectangle({x}, {y}, {w}, {h}, {fg});')
            _wrap_with_condition(dst, indent, widget, content)
            return
        
        # Generate safe ID from entity_id
        safe_id = entity_id.replace(".", "_").replace("-", "_")
        
        # Add marker comment for parser
        content.append(f'{indent}// widget:progress_bar id:{widget.id} type:progress_bar x:{x} y:{y} w:{w} h:{h} entity:{entity_id} label:"{label}" bar_height:{bar_height} border:{border_width}')
        
        # Calculate vertical layout
        label_y = y
        bar_y = y
        
        if show_label and (label or show_percentage):
            # Label/percentage row at top
            if label and show_percentage:
                # Both label and percentage
                label_font = _resolve_font_by_size(12)
                content.append(f'{indent}it.printf({x}, {label_y}, {label_font}, {fg}, "{label}");')
                # Percentage on the right
                content.append(f'{indent}it.printf({x}+{w}-30, {label_y}, {label_font}, {fg}, "%.0f%%", id({safe_id}).state);')
            elif label:
                # Label only
                label_font = _resolve_font_by_size(12)
                content.append(f'{indent}it.printf({x}, {label_y}, {label_font}, {fg}, "{label}");')
            elif show_percentage:
                # Percentage only
                label_font = _resolve_font_by_size(12)
                content.append(f'{indent}it.printf({x}, {label_y}, {label_font}, {fg}, "%.0f%%", id({safe_id}).state);')
            
            bar_y = label_y + 16
        
        # Draw progress bar border
        content.append(f'{indent}it.rectangle({x}, {bar_y}, {w}, {bar_height}, {fg});')
        
        # Draw progress bar fill (clamp to 0-100%)
        content.append(f'{indent}// Fill progress bar based on sensor value (0-100%)')
        content.append(f'{indent}{{')
        content.append(f'{indent}  float progress = id({safe_id}).state;')
        content.append(f'{indent}  if (progress < 0) progress = 0;')
        content.append(f'{indent}  if (progress > 100) progress = 100;')
        content.append(f'{indent}  int fill_width = (int)(({w} - 2) * (progress / 100.0));')
        content.append(f'{indent}  if (fill_width > 0) {{')
        content.append(f'{indent}    it.filled_rectangle({x}+1, {bar_y}+1, fill_width, {bar_height}-2, {fg});')
        content.append(f'{indent}  }}')
        content.append(f'{indent}}}')
        _wrap_with_condition(dst, indent, widget, content)
        return

    # Battery icon widget - dynamic icon based on battery level
    if wtype == "battery_icon":
        entity_id = (widget.entity_id or "").strip()
        size = int(props.get("size", 48) or 48)
        font_id = f"font_mdi_{size}"
        
        if not entity_id:
            # No entity configured - show static battery icon
            content.append(f'{indent}// widget:battery_icon id:{widget.id} (no entity configured)')
            content.append(f'{indent}it.printf({x}, {y}, id({font_id}), {fg}, "\\U000F0079");  // battery')
            _wrap_with_condition(dst, indent, widget, content)
            return
        
        # Generate safe ID from entity_id
        safe_id = entity_id.replace(".", "_").replace("-", "_")
        
        # Add marker comment for parser
        content.append(f'{indent}// widget:battery_icon id:{widget.id} type:battery_icon x:{x} y:{y} w:{w} h:{h} entity:{entity_id} size:{size} color:{base_color}')
        
        # Add logic to pick battery icon based on level
        content.append(f'{indent}{{')
        content.append(f'{indent}  float level = id({safe_id}).state;')
        content.append(f'{indent}  const char* icon;')
        content.append(f'{indent}  if (level <= 10)      icon = "\\U000F007A";  // battery-10')
        content.append(f'{indent}  else if (level <= 20) icon = "\\U000F007B";  // battery-20')
        content.append(f'{indent}  else if (level <= 30) icon = "\\U000F007C";  // battery-30')
        content.append(f'{indent}  else if (level <= 40) icon = "\\U000F007D";  // battery-40')
        content.append(f'{indent}  else if (level <= 50) icon = "\\U000F007E";  // battery-50')
        content.append(f'{indent}  else if (level <= 60) icon = "\\U000F007F";  // battery-60')
        content.append(f'{indent}  else if (level <= 70) icon = "\\U000F0080";  // battery-70')
        content.append(f'{indent}  else if (level <= 80) icon = "\\U000F0081";  // battery-80')
        content.append(f'{indent}  else if (level <= 90) icon = "\\U000F0082";  // battery-90')
        content.append(f'{indent}  else                  icon = "\\U000F0079";  // battery (full)')
        content.append(f'{indent}  it.printf({x}, {y}, id({font_id}), {fg}, "%s", icon);')
        content.append(f'{indent}  // Show percentage below icon')
        content.append(f'{indent}  it.printf({x}, {y}+{size}+2, id(font_small), {fg}, "%.0f%%", level);')
        content.append(f'{indent}}}')
        _wrap_with_condition(dst, indent, widget, content)
        return

    # Rectangle / filled rectangle
    if wtype == "shape_rect":
        fill = bool(props.get("fill"))
        border_width = int(props.get("border_width", 1) or 1)
        opacity = int(props.get("opacity", 100) or 100)
        
        # Add marker comment for parser
        fill_str = "true" if fill else "false"
        content.append(f'{indent}// widget:shape_rect id:{widget.id} type:shape_rect x:{x} y:{y} w:{w} h:{h} fill:{fill_str} border:{border_width} color:{base_color}')
        
        # Check if we should use grey dithering pattern (50% checkerboard)
        use_grey_pattern = (base_color == "gray" and fill)
        
        if fill:
            if use_grey_pattern:
                # Grey: create 50% checkerboard pattern for visual distinction from solid black
                content.append(f"{indent}// Grey fill using 50% checkerboard dithering pattern")
                content.append(f"{indent}for (int dy = 0; dy < {h}; dy++) {{")
                content.append(f"{indent}  for (int dx = 0; dx < {w}; dx++) {{")
                content.append(f"{indent}    if ((dx + dy) % 2 == 0) {{")
                content.append(f"{indent}      it.draw_pixel_at({x}+dx, {y}+dy, COLOR_ON);")
                content.append(f"{indent}    }}")
                content.append(f"{indent}  }}")
                content.append(f"{indent}}}")
            else:
                # Solid fill (black or white)
                content.append(f"{indent}it.filled_rectangle({x}, {y}, {w}, {h}, {fg});")
            if border_width > 1:
                content.append(f"{indent}it.rectangle({x}, {y}, {w}, {h}, {fg});")
        else:
            if border_width <= 1:
                content.append(f"{indent}it.rectangle({x}, {y}, {w}, {h}, {fg});")
            else:
                # Approximate thicker border using multiple rectangles.
                content.append(f"{indent}// rectangle with border_width={border_width}")
                content.append(f"{indent}for (int i = 0; i < {border_width}; i++) {{")
                content.append(
                    f"{indent}  it.rectangle({x}+i, {y}+i, {w}-2*i, {h}-2*i, {fg});"
                )
                content.append(f"{indent}}}")
        _wrap_with_condition(dst, indent, widget, content)
        return

    # Circle / filled circle (use width/height box)
    if wtype == "shape_circle":
        r = max(1, min(w, h) // 2)
        cx = x + w // 2
        cy = y + h // 2
        fill = bool(props.get("fill"))
        border_width = int(props.get("border_width", 1) or 1)
        
        # Add marker comment for parser
        fill_str = "true" if fill else "false"
        content.append(f'{indent}// widget:shape_circle id:{widget.id} type:shape_circle x:{x} y:{y} w:{w} h:{h} fill:{fill_str} border:{border_width} color:{base_color}')
        
        # Check if we should use grey dithering pattern
        use_grey_pattern = (base_color == "gray" and fill)
        
        if fill:
            if use_grey_pattern:
                # Grey: create 50% checkerboard pattern within circle bounds
                content.append(f"{indent}// Grey fill using 50% checkerboard dithering pattern")
                content.append(f"{indent}for (int dy = -{r}; dy <= {r}; dy++) {{")
                content.append(f"{indent}  for (int dx = -{r}; dx <= {r}; dx++) {{")
                content.append(f"{indent}    if (dx*dx + dy*dy <= {r}*{r}) {{")
                content.append(f"{indent}      if ((dx + dy) % 2 == 0) {{")
                content.append(f"{indent}        it.draw_pixel_at({cx}+dx, {cy}+dy, COLOR_ON);")
                content.append(f"{indent}      }}")
                content.append(f"{indent}    }}")
                content.append(f"{indent}  }}")
                content.append(f"{indent}}}")
            else:
                # Solid fill (black or white)
                content.append(f"{indent}it.filled_circle({cx}, {cy}, {r}, {fg});")
            if border_width > 1:
                content.append(f"{indent}it.circle({cx}, {cy}, {r}, {fg});")
        else:
            if border_width <= 1:
                content.append(f"{indent}it.circle({cx}, {cy}, {r}, {fg});")
            else:
                content.append(f"{indent}// circle with border_width={border_width}")
                content.append(f"{indent}for (int i = 0; i < {border_width}; i++) {{")
                content.append(f"{indent}  it.circle({cx}, {cy}, {r}-i, {fg});")
                content.append(f"{indent}}}")
        _wrap_with_condition(dst, indent, widget, content)
        return

    # Line: from (x,y) to (x+width,y+height) using width/height as dx/dy
    if wtype == "line":
        dx = w
        dy = h
        stroke_width = int(props.get("stroke_width", 1) or 1)
        # Add marker comment for parser
        content.append(f'{indent}// widget:line id:{widget.id} type:line x:{x} y:{y} w:{w} h:{h} stroke:{stroke_width} color:{base_color}')
        content.append(f"{indent}it.line({x}, {y}, {x}+{dx}, {y}+{dy}, {fg});")
        _wrap_with_condition(dst, indent, widget, content)
        return

    # Image widget
    if wtype == "image":
        path = props.get("path", "").strip()
        if not path:
            # No path configured - show placeholder
            content.append(f'{indent}// widget:image id:{widget.id} type:image x:{x} y:{y} w:{w} h:{h}')
            content.append(f'{indent}// No image path configured')
            content.append(f'{indent}it.rectangle({x}, {y}, {w}, {h}, {fg});')
            _wrap_with_condition(dst, indent, widget, content)
            return
        
        # Generate safe ID from path (same logic as in _generate_fonts)
        safe_id = path.replace("/", "_").replace(".", "_").replace("-", "_").replace(" ", "_")
        safe_id = f"img_{safe_id}"
        
        # Check if image should be inverted
        invert = bool(props.get("invert"))
        
        # Add marker comment for parser
        content.append(f'{indent}// widget:image id:{widget.id} type:image x:{x} y:{y} w:{w} h:{h} path:"{path}" invert:{invert}')
        
        if invert:
            content.append(f'{indent}it.image({x}, {y}, id({safe_id}), COLOR_OFF, COLOR_ON);')
        else:
            content.append(f'{indent}it.image({x}, {y}, id({safe_id}));')
        _wrap_with_condition(dst, indent, widget, content)
        return

    # Remote / online image (puppet) widget - rendered from online_image id
    if wtype == "online_image":
        props_url = (props.get("url") or "").strip()
        safe_id = f"img_{widget.id}".replace("-", "_")
        # Marker comment
        content.append(f'{indent}// widget:online_image id:{widget.id} type:online_image x:{x} y:{y} w:{w} h:{h} url:"{props_url}"')
        content.append(f'{indent}it.image({x}, {y}, id({safe_id}));')
        _wrap_with_condition(dst, indent, widget, content)
        return

    # Fallback / unknown
    if wtype == "image":
        image_id = (props.get("image_id") or "").strip()
        if image_id:
            dst.append(f"{indent}it.image({x}, {y}, id({image_id}));")
        else:
            dst.append(f"{indent}// image widget missing image_id at ({x},{y})")
        return

    # History widget: placeholder visualization; requires precomputed entity
    if wtype == "history":
        entity_id = (props.get("entity_id") or widget.entity_id or "").replace('"', '\\"')
        style = (props.get("style") or "bars").lower()
        label = entity_id or "history"
        font = _resolve_font(props)
        content.append(f"{indent}// history widget for {entity_id}; expects external aggregation")
        content.append(f'{indent}it.print({x}, {y}, {font}, {fg}, "{label}");')
        # Simple placeholder box/lines
        hx = x
        hy = y + 14
        hw = max(10, w)
        hh = max(6, h - 16)
        content.append(f"{indent}it.rectangle({hx}, {hy}, {hw}, {hh}, {fg});")
        if style == "line":
            content.append(f"{indent}it.line({hx+2}, {hy+hh-3}, {hx+hw-2}, {hy+3}, {fg});")
        else:
            content.append(f"{indent}// draw simple bar-style segments as placeholder")
        _wrap_with_condition(dst, indent, widget, content)
        return

    # Unknown type: emit comment for safety
    dst.append(f'{indent}// TODO: unsupported widget type "{widget.type}" at ({x},{y})')
    if wtype == "image":
        image_id = props.get("image_id")
        if image_id:
            dst.append(f"{indent}it.image({x}, {y}, id({image_id}));")
        else:
            dst.append(f"{indent}// image widget without image_id; nothing drawn")
        return

    # History graph widget (placeholder: renders a labeled box)
    if wtype == "history":
        title = (widget.title or "history").replace('"', '\\"')
        font = _resolve_font(props)
        dst.append(f"{indent}// History widget placeholder for {title}")
        dst.append(f"{indent}it.rectangle({x}, {y}, {w}, {h}, {fg});")
        dst.append(f"{indent}it.print({x}+2, {y}+2, {font}, {fg}, \"{title}\");")
        return

    # Fallback
    dst.append(f'{indent}// Unsupported widget type "{widget.type}" at ({x},{y},{w},{h})')